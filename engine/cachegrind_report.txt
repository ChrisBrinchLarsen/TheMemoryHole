--------------------------------------------------------------------------------
-- Metadata
--------------------------------------------------------------------------------
Invocation:       /usr/bin/cg_annotate cachegrind.out.23854 cachegrind.out.23910
Command 1:        ./unit
Command 2:        ./sim testing/Architectures/SimpleCPU.md testing/C_Programs/matrix_good_debugcomm.dis
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Threshold:        0.1%
Annotation:       on

--------------------------------------------------------------------------------
-- Summary
--------------------------------------------------------------------------------
Ir_________________ 

71,500,423 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
-- File:function summary
--------------------------------------------------------------------------------
  Ir______________________  file:function

< 9,585,740 (13.4%, 13.4%)  /usr/src/debug/glibc/glibc/stdio-common/vfprintf-process-arg.c:__printf_buffer

< 8,839,587 (12.4%, 25.8%)  /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c:
  6,586,717  (9.2%)           __printf_buffer
  2,252,870  (3.2%)           __vfprintf_internal

< 8,519,572 (11.9%, 37.7%)  /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_write.c:__printf_buffer_write

< 4,394,837  (6.1%, 43.8%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:
  4,314,135  (6.0%)           __memcpy_avx_unaligned_erms
     77,728  (0.1%)           __mempcpy_avx_unaligned_erms

< 3,919,508  (5.5%, 49.3%)  /home/zupreme/Documents/University/TheMemoryHole/engine/cache.c:
    743,265  (1.0%)           get_address
    684,993  (1.0%)           get_line_index_from_tag
    508,467  (0.7%)           fetch_line
    348,480  (0.5%)           get_replacement_line_index
    337,879  (0.5%)           handle_miss
    289,148  (0.4%)           increment_line_LRU
    275,602  (0.4%)           change_dirtiness
    182,920  (0.3%)           cache_rd_w
    179,631  (0.3%)           add_operation_to_checksum
    116,754  (0.2%)           change_validity
     75,824  (0.1%)           cache_rd_instr

< 3,874,569  (5.4%, 54.7%)  /usr/src/debug/glibc/glibc/stdio-common/_itoa.c:_itoa_word

< 3,811,493  (5.3%, 60.1%)  /usr/src/debug/glibc/glibc/stdio-common/vfscanf-internal.c:__vfscanf_internal

< 3,621,332  (5.1%, 65.1%)  /home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c:
  1,320,720  (1.8%)           read_exec
    870,090  (1.2%)           count_hexes
    534,160  (0.7%)           to_hex
    499,882  (0.7%)           is_hex
    396,480  (0.6%)           to_hex2

< 2,755,155  (3.9%, 69.0%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-avx2.S:
  2,754,924  (3.9%)           __strchrnul_avx2

< 2,707,191  (3.8%, 72.8%)  /home/zupreme/Documents/University/TheMemoryHole/engine/memory.c:
  1,769,550  (2.5%)           memory_delete
    495,600  (0.7%)           memory_wr_b
    413,788  (0.6%)           get_page

< 2,590,434  (3.6%, 76.4%)  /home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c:
  1,711,800  (2.4%)           SIP64
    310,092  (0.4%)           hashmap_get_with_hash
    124,575  (0.2%)           bucket_at
     99,660  (0.1%)           bucket_at0
     90,345  (0.1%)           get_hash
     85,284  (0.1%)           hashmap_get

< 2,444,353  (3.4%, 79.8%)  /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c:
  1,201,190  (1.7%)           __printf_buffer_flush_to_file
    551,724  (0.8%)           __printf_buffer_to_file_done
    461,554  (0.6%)           __printf_buffer_to_file_switch
    229,885  (0.3%)           __printf_buffer_to_file_init

< 1,443,202  (2.0%, 81.8%)  /usr/src/debug/glibc/glibc/posix/regexec.c:
  1,235,308  (1.7%)           re_search_internal
    110,400  (0.2%)           regexec@@GLIBC_2.3.4

< 1,346,071  (1.9%, 83.7%)  /home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c:
    437,139  (0.6%)           simulate
    186,756  (0.3%)           ExecuteInstruction
    130,662  (0.2%)           rdReg
    125,145  (0.2%)           ProcessB
    118,440  (0.2%)           ProcessI_A
     76,080  (0.1%)           programLineMap_hash

< 1,240,137  (1.7%, 85.4%)  /usr/src/debug/glibc/glibc/stdio-common/fprintf.c:fprintf

<   943,358  (1.3%, 86.8%)  /usr/src/debug/glibc/glibc/libio/fileops.c:
    906,292  (1.3%)           _IO_file_xsputn@@GLIBC_2.2.5

<   929,375  (1.3%, 88.1%)  /usr/src/debug/glibc/glibc/libio/iofwrite.c:fwrite

<   834,552  (1.2%, 89.2%)  /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_done.c:__printf_buffer_done

<   733,891  (1.0%, 90.3%)  /usr/src/debug/glibc/glibc/stdio-common/../string/bits/string_fortified.h:
    729,270  (1.0%)           __printf_buffer_write

<   731,636  (1.0%, 91.3%)  /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h:
    637,994  (0.9%)           __printf_buffer
     93,642  (0.1%)           __vfscanf_internal

<   702,083  (1.0%, 92.3%)  /usr/src/debug/glibc/glibc/libio/genops.c:
    478,860  (0.7%)           _IO_sputbackc

<   681,905  (1.0%, 93.2%)  /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h:
    405,640  (0.6%)           __printf_buffer
    275,862  (0.4%)           __printf_buffer_to_file_init

<   500,357  (0.7%, 93.9%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S:__memset_avx2_unaligned_erms

<   462,826  (0.6%, 94.6%)  /usr/src/debug/glibc/glibc/libio/libioP.h:
    406,602  (0.6%)           fwrite

<   460,444  (0.6%, 95.2%)  /home/zupreme/Documents/University/TheMemoryHole/engine/mmu.c:
    317,184  (0.4%)           mmu_wr_b_instr
     85,302  (0.1%)           mmu_rd_instr

<   447,616  (0.6%, 95.8%)  /usr/src/debug/glibc/glibc/stdlib/../stdlib/strtol_l.c:
    437,456  (0.6%)           ____strtoul_l_internal

<   403,039  (0.6%, 96.4%)  /usr/src/debug/glibc/glibc/malloc/malloc.c:
    150,405  (0.2%)           free
    108,392  (0.2%)           malloc
     80,335  (0.1%)           _int_malloc

<   385,377  (0.5%, 96.9%)  ???:
    385,269  (0.5%)           ???

<   282,522  (0.4%, 97.3%)  /usr/src/debug/glibc/glibc/posix/regex_internal.c:
    108,560  (0.2%)           re_search_internal

<   234,470  (0.3%, 97.7%)  /usr/src/debug/glibc/glibc/libio/iogetline.c:
    223,385  (0.3%)           _IO_getline_info

<   206,910  (0.3%, 97.9%)  /usr/src/debug/glibc/glibc/libio/iofgets.c:fgets

<   153,747  (0.2%, 98.2%)  /usr/src/debug/glibc/glibc/math/../sysdeps/ieee754/dbl-64/e_pow.c:__ieee754_pow_fma

<   149,104  (0.2%, 98.4%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-avx2.S:__strlen_avx2

<   137,407  (0.2%, 98.6%)  /usr/src/debug/glibc/glibc/elf/dl-lookup.c:
     88,525  (0.1%)           do_lookup_x

<   116,155  (0.2%, 98.7%)  /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memchr-avx2.S:__memchr_avx2

<   112,961  (0.2%, 98.9%)  /usr/src/debug/glibc/glibc/libio/strops.c:
    102,296  (0.1%)           _IO_str_init_static_internal

<   102,296  (0.1%, 99.0%)  /usr/src/debug/glibc/glibc/stdio-common/isoc99_sscanf.c:__isoc99_sscanf

--------------------------------------------------------------------------------
-- Function:file summary
--------------------------------------------------------------------------------
  Ir_______________________  function:file

> 17,216,091 (24.1%, 24.1%)  __printf_buffer:
   9,585,740 (13.4%)           /usr/src/debug/glibc/glibc/stdio-common/vfprintf-process-arg.c
   6,586,717  (9.2%)           /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c
     637,994  (0.9%)           /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h
     405,640  (0.6%)           /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h

>  9,248,842 (12.9%, 37.0%)  __printf_buffer_write:
   8,519,572 (11.9%)           /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_write.c
     729,270  (1.0%)           /usr/src/debug/glibc/glibc/stdio-common/../string/bits/string_fortified.h

>  4,314,135  (6.0%, 43.0%)  __memcpy_avx_unaligned_erms:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>  3,949,591  (5.5%, 48.6%)  __vfscanf_internal:
   3,811,493  (5.3%)           /usr/src/debug/glibc/glibc/stdio-common/vfscanf-internal.c
      93,642  (0.1%)           /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h

>  3,874,569  (5.4%, 54.0%)  _itoa_word:/usr/src/debug/glibc/glibc/stdio-common/_itoa.c

>  2,754,924  (3.9%, 57.8%)  __strchrnul_avx2:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-avx2.S

>  2,252,870  (3.2%, 61.0%)  __vfprintf_internal:/usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c

>  1,769,550  (2.5%, 63.5%)  memory_delete:/home/zupreme/Documents/University/TheMemoryHole/engine/memory.c

>  1,711,800  (2.4%, 65.9%)  SIP64:/home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c

>  1,345,500  (1.9%, 67.7%)  re_search_internal:
   1,235,308  (1.7%)           /usr/src/debug/glibc/glibc/posix/regexec.c
     108,560  (0.2%)           /usr/src/debug/glibc/glibc/posix/regex_internal.c

>  1,335,977  (1.9%, 69.6%)  fwrite:
     929,375  (1.3%)           /usr/src/debug/glibc/glibc/libio/iofwrite.c
     406,602  (0.6%)           /usr/src/debug/glibc/glibc/libio/libioP.h

>  1,320,720  (1.8%, 71.5%)  read_exec:/home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c

>  1,240,137  (1.7%, 73.2%)  fprintf:/usr/src/debug/glibc/glibc/stdio-common/fprintf.c

>  1,201,598  (1.7%, 74.9%)  __printf_buffer_flush_to_file:
   1,201,190  (1.7%)           /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c

>    906,904  (1.3%, 76.1%)  _IO_file_xsputn@@GLIBC_2.2.5:
     906,292  (1.3%)           /usr/src/debug/glibc/glibc/libio/fileops.c

>    870,090  (1.2%, 77.4%)  count_hexes:/home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c

>    834,552  (1.2%, 78.5%)  __printf_buffer_done:/usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_done.c

>    743,265  (1.0%, 79.6%)  get_address:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    684,993  (1.0%, 80.5%)  get_line_index_from_tag:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    551,724  (0.8%, 81.3%)  __printf_buffer_to_file_done:/usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c

>    534,160  (0.7%, 82.0%)  to_hex:/home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c

>    508,467  (0.7%, 82.8%)  fetch_line:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    505,747  (0.7%, 83.5%)  __printf_buffer_to_file_init:
     275,862  (0.4%)           /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h
     229,885  (0.3%)           /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c

>    500,357  (0.7%, 84.2%)  __memset_avx2_unaligned_erms:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

>    499,882  (0.7%, 84.9%)  is_hex:/home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c

>    495,600  (0.7%, 85.6%)  memory_wr_b:/home/zupreme/Documents/University/TheMemoryHole/engine/memory.c

>    478,860  (0.7%, 86.2%)  _IO_sputbackc:/usr/src/debug/glibc/glibc/libio/genops.c

>    461,554  (0.6%, 86.9%)  __printf_buffer_to_file_switch:/usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c

>    437,456  (0.6%, 87.5%)  ____strtoul_l_internal:/usr/src/debug/glibc/glibc/stdlib/../stdlib/strtol_l.c

>    437,139  (0.6%, 88.1%)  simulate:/home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c

>    413,788  (0.6%, 88.7%)  get_page:/home/zupreme/Documents/University/TheMemoryHole/engine/memory.c

>    396,480  (0.6%, 89.2%)  to_hex2:/home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c

>    386,573  (0.5%, 89.8%)  ???:
     385,269  (0.5%)           ???

>    348,480  (0.5%, 90.3%)  get_replacement_line_index:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    337,879  (0.5%, 90.7%)  handle_miss:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    317,184  (0.4%, 91.2%)  mmu_wr_b_instr:/home/zupreme/Documents/University/TheMemoryHole/engine/mmu.c

>    310,092  (0.4%, 91.6%)  hashmap_get_with_hash:/home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c

>    289,148  (0.4%, 92.0%)  increment_line_LRU:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    275,602  (0.4%, 92.4%)  change_dirtiness:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    251,248  (0.4%, 92.7%)  fgets:
     206,910  (0.3%)           /usr/src/debug/glibc/glibc/libio/iofgets.c

>    238,333  (0.3%, 93.1%)  _IO_getline_info:
     223,385  (0.3%)           /usr/src/debug/glibc/glibc/libio/iogetline.c

>    186,756  (0.3%, 93.3%)  ExecuteInstruction:/home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c

>    182,920  (0.3%, 93.6%)  cache_rd_w:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    179,631  (0.3%, 93.8%)  add_operation_to_checksum:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    161,512  (0.2%, 94.1%)  __ieee754_pow_fma:
     153,747  (0.2%)           /usr/src/debug/glibc/glibc/math/../sysdeps/ieee754/dbl-64/e_pow.c

>    157,653  (0.2%, 94.3%)  free:
     150,405  (0.2%)           /usr/src/debug/glibc/glibc/malloc/malloc.c

>    149,104  (0.2%, 94.5%)  __strlen_avx2:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-avx2.S

>    139,984  (0.2%, 94.7%)  __isoc99_sscanf:
     102,296  (0.1%)           /usr/src/debug/glibc/glibc/stdio-common/isoc99_sscanf.c

>    130,662  (0.2%, 94.9%)  rdReg:/home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c

>    125,145  (0.2%, 95.1%)  ProcessB:/home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c

>    124,575  (0.2%, 95.2%)  bucket_at:/home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c

>    118,440  (0.2%, 95.4%)  ProcessI_A:/home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c

>    116,754  (0.2%, 95.6%)  change_validity:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

>    116,155  (0.2%, 95.7%)  __memchr_avx2:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memchr-avx2.S

>    110,400  (0.2%, 95.9%)  regexec@@GLIBC_2.3.4:/usr/src/debug/glibc/glibc/posix/regexec.c

>    109,420  (0.2%, 96.0%)  malloc:
     108,392  (0.2%)           /usr/src/debug/glibc/glibc/malloc/malloc.c

>    102,296  (0.1%, 96.2%)  _IO_str_init_static_internal:/usr/src/debug/glibc/glibc/libio/strops.c

>     99,660  (0.1%, 96.3%)  bucket_at0:/home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c

>     91,751  (0.1%, 96.4%)  do_lookup_x:
      88,525  (0.1%)           /usr/src/debug/glibc/glibc/elf/dl-lookup.c

>     90,345  (0.1%, 96.6%)  get_hash:/home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c

>     85,302  (0.1%, 96.7%)  mmu_rd_instr:/home/zupreme/Documents/University/TheMemoryHole/engine/mmu.c

>     85,284  (0.1%, 96.8%)  hashmap_get:/home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c

>     80,335  (0.1%, 96.9%)  _int_malloc:/usr/src/debug/glibc/glibc/malloc/malloc.c

>     77,728  (0.1%, 97.0%)  __mempcpy_avx_unaligned_erms:/usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

>     76,080  (0.1%, 97.1%)  programLineMap_hash:/home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c

>     75,824  (0.1%, 97.2%)  cache_rd_instr:/home/zupreme/Documents/University/TheMemoryHole/engine/cache.c

--------------------------------------------------------------------------------
-- Annotated source file: /home/zupreme/Documents/University/TheMemoryHole/engine/cache.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 11 ----------------------------------------
      .         uint32_t cache_checksum;
      .         
      .         int ADDR_LEN = 32;
      .         uint32_t N_CACHE_LEVELS;
      .         
      .         Cache_t* caches = NULL;
      .         Cache_t* L1i = NULL;
      .         
     30 (0.0%)  Cache_t* get_caches() { return caches; };
     10 (0.0%)  Cache_t* get_l1i() { return L1i; };
      .         
      .         FILE* CACHE_LOG;
      .         
      .         // Policies
      .         #define LRU_REPLACEMENT_POLICY 0
      .         #define RANDOM_REPLACEMENT_POLICY 1
      .         const uint32_t ACTIVE_REPLACEMENT_POLICY = LRU_REPLACEMENT_POLICY;
      .         
-- line 28 ----------------------------------------
-- line 44 ----------------------------------------
      .         Cache_t* cache_new(uint32_t layer, uint32_t cacheSize, uint32_t block_size, uint32_t associativity);
      .         CacheLine_t cacheline_new(char* block);
      .         void change_validity(Cache_t* cache, int set_index, int line_index, bool new_validity);
      .         void change_dirtiness(Cache_t* cache, int set_index, int line_index, bool new_dirty);
      .         
      .         void add_operation_to_checksum(uint32_t type, uint32_t cache_idx, uint32_t set_idx, uint32_t line_idx);
      .         
      .         
  3,834 (0.0%)  void cache_wr_w(struct memory *mem, int addr_int, uint32_t data) {
  4,473 (0.0%)      fprintf(CACHE_LOG, "ww 0x%x %d\n", addr_int, data);
      .         
  4,473 (0.0%)      CacheLine_t* line = fetch_line(&caches[0], addr_int, mem);
      .         
  4,473 (0.0%)      Address_t addr = get_address(&caches[0], addr_int);
  7,668 (0.0%)      change_dirtiness(&caches[0],
    639 (0.0%)                       addr.set_index,
      .                              get_line_index_from_tag(&caches[0], addr),
      .                              1);
      .         
      .         
  4,473 (0.0%)      memcpy(&line->block[addr.block_offset], &data, sizeof(uint32_t));
  1,917 (0.0%)  }
      .         
      .         void cache_wr_h(struct memory *mem, int addr_int, uint16_t data) {
      .             fprintf(CACHE_LOG, "wh 0x%x %d\n", addr_int, data);
      .             // TODO : Check if address in half-aligned
      .             CacheLine_t* line = fetch_line(&caches[0], addr_int, mem);
      .             
      .             Address_t addr = get_address(&caches[0], addr_int);
      .             change_dirtiness(&caches[0],
-- line 73 ----------------------------------------
-- line 74 ----------------------------------------
      .                              addr.set_index,
      .                              get_line_index_from_tag(&caches[0], addr),
      .                              1);
      .         
      .         
      .             memcpy(&line->block[addr.block_offset], &data, sizeof(uint16_t));
      .         }
      .         
     42 (0.0%)  void cache_wr_b(struct memory *mem, int addr_int, uint8_t data) {
     48 (0.0%)      fprintf(CACHE_LOG, "wb 0x%x %d\n", addr_int, data);
      .             
     42 (0.0%)      CacheLine_t* line = fetch_line(&caches[0], addr_int, mem);
     42 (0.0%)      Address_t addr = get_address(&caches[0], addr_int);
     72 (0.0%)      change_dirtiness(&caches[0],
      6 (0.0%)                       addr.set_index,
      .                              get_line_index_from_tag(&caches[0], addr),
      .                              1);
      .         
     42 (0.0%)      memcpy(&line->block[addr.block_offset], &data, sizeof(uint8_t));
     18 (0.0%)  }
      .         
 23,695 (0.0%)  int cache_rd_instr(struct memory *mem, int addr_int) {
 14,217 (0.0%)      if (L1i == NULL) { // in case we aren't using an instruction cache, we simply redirect this to the normal cache_rd_w method instead
 28,434 (0.0%)          return cache_rd_w(mem, addr_int);
      .             }
      .         
      .             fprintf(CACHE_LOG, "rw 0x%x\n", addr_int); // TODO is this logging correct?
      .             char* block = fetch_line(L1i, addr_int, mem)->block;
      .         
      .             Address_t addr = get_address(L1i, addr_int);
      .         
      .             return (int)(*(uint32_t*)&block[addr.block_offset]);
  9,478 (0.0%)  }
      .         
      .         
 26,900 (0.0%)  int cache_rd_w(struct memory *mem, int addr_int) {
 37,660 (0.1%)      fprintf(CACHE_LOG, "rw 0x%x\n", addr_int);
 43,040 (0.1%)      char* block = fetch_line(&caches[0], addr_int, mem)->block;
      .         
 37,660 (0.1%)      Address_t addr = get_address(&caches[0], addr_int);
      .         
 26,900 (0.0%)      return (int)(*(uint32_t*)&block[addr.block_offset]);
 10,760 (0.0%)  }
      .         
      .         int cache_rd_h(struct memory *mem, int addr_int) {
      .             fprintf(CACHE_LOG, "rh 0x%x\n", addr_int);
      .             char* block = fetch_line(&caches[0], addr_int, mem)->block;
      .         
      .             Address_t addr = get_address(&caches[0], addr_int);
      .         
      .             return (int)(*(uint16_t*)&block[addr.block_offset]);
      .         }
      .         
     40 (0.0%)  int cache_rd_b(struct memory *mem, int addr_int) {
     56 (0.0%)      fprintf(CACHE_LOG, "rb 0x%x\n", addr_int);
     64 (0.0%)      char* block = fetch_line(&caches[0], addr_int, mem)->block;
      .         
     56 (0.0%)      Address_t addr = get_address(&caches[0], addr_int);
      .         
     48 (0.0%)      return (int)block[addr.block_offset];
     16 (0.0%)  }
      .         
      .         
      .         /// @brief recursive function that finds a block, starting at some Layer. Updates caches accordingly
      .         /// @param layer the layer of the cache
      .         /// @param addr_int address
      .         /// @param mem memory
      .         /// @param mark_dirty whether to mark things dirty (in case of a write) 
      .         /// @return 
 45,432 (0.1%)  CacheLine_t* fetch_line(Cache_t* cache, uint32_t addr_int, struct memory *mem) {
 53,004 (0.1%)      Address_t addr = get_address(cache, addr_int);
      .         
 37,860 (0.1%)      increment_line_LRU(cache, addr.set_index);
      .         
      .             // The index of the line that our address points to in the set our index points to
 53,004 (0.1%)      int line_index = get_line_index_from_tag(cache, addr);
      .         
      .             // check if line is already in set, otherwise add it. CACHE HIT/MISS
 15,144 (0.0%)      if (line_index == -1) { // MISS
 11,658 (0.0%)          line_index = get_replacement_line_index(cache, addr.set_index);
 13,601 (0.0%)          handle_miss(cache, addr, mem);
      .             }
      .             else { // HIT
 84,435 (0.1%)          cache->sets[addr.set_index][line_index].LRU = 0; // least recently used; just now
      .                 
 73,177 (0.1%)          fprintf(CACHE_LOG, "H %d %d %d\n", cache->layer+1, addr.set_index, line_index);
      .             }
      .         
106,008 (0.1%)      return &(cache->sets[addr.set_index][line_index]);
 15,144 (0.0%)  }
      .         
 23,316 (0.0%)  void handle_miss(Cache_t* cache, Address_t addr, struct memory* mem) {
 21,373 (0.0%)      fprintf(CACHE_LOG, "M %d %d\n", cache->layer+1, addr.set_index);
      .         
      .             // replace, back-invalidate and evict another line in this set first.
 11,658 (0.0%)      int line_index = get_replacement_line_index(cache, addr.set_index);
 29,145 (0.0%)      CacheLine_t* victim = &cache->sets[addr.set_index][line_index];
  7,772 (0.0%)      if (victim->valid) { // sometimes the line to replace is unused, in which case we don't need to invalidate or evict anything
  7,660 (0.0%)          if (cache->layer != 0) { //back invalidation
  7,002 (0.0%)              uint32_t inval_line_addr = (victim->tag << (cache->set_bit_length + cache->block_offset_bit_length)) | (addr.set_index << cache->block_offset_bit_length);
  2,723 (0.0%)              invalidate_line(cache->parent_cache, inval_line_addr, mem); // back invalidation request 
      .                 }
  7,660 (0.0%)          if (victim->dirty) {
 10,296 (0.0%)              uint32_t evict_addr = (victim->tag << (cache->set_bit_length + cache->block_offset_bit_length)) | (addr.set_index << cache->block_offset_bit_length);
  3,432 (0.0%)              evict_cache_line(cache, evict_addr, victim, mem);
      .                 }
      .             }
      .         
      .             // the cache below returns its entire block, we need to know which part of that cache is our block (since it might be smaller)
  1,943 (0.0%)      CacheLine_t* received_cache_line_from_child = NULL;
      .             char* block;
  1,943 (0.0%)      uint32_t block_offset = 0;
  7,772 (0.0%)      if (!(cache->child_cache == NULL)) { // If not at last layer of cache, request from lower cache
      .                 // recursive call
 12,312 (0.0%)          received_cache_line_from_child = fetch_line(cache->child_cache, addr.full_addr, mem);
  4,617 (0.0%)          block = received_cache_line_from_child->block; // TODO fjern block var idk
      .         
      .                 // in case were getting stuff from another layer of cache, we need to find the offset within the block we've been given
      .         
      .                 // mask out the top and bottom bits. If L1 uses 00000011 and L2 uses 00001111, the block_idx after shifting and masking will be 00001100
 16,929 (0.0%)          block_offset = (addr.full_addr >> cache->block_offset_bit_length) << cache->block_offset_bit_length;
 24,624 (0.0%)          uint32_t mask = ((uint32_t)pow(2,caches->child_cache->block_offset_bit_length)-1);
      .                 
  4,617 (0.0%)          block_offset = block_offset & mask;
      .         
      .             } else { // at last layer; fetch from main memory instead
  2,424 (0.0%)          fprintf(CACHE_LOG, "RAM\n");
      .                 // when fetching from main memory, the block offset will just be 0, since we've already requested our specific size.
  3,636 (0.0%)          block = find_block(mem, addr.full_addr, cache->block_size);
      .             }
      .         
      .             // Fetched a block into the cache
 25,259 (0.0%)      fprintf(CACHE_LOG, "F %d %d %d\n", cache->layer+1, addr.set_index, line_index);
      .         
      .             // update line
 13,601 (0.0%)      change_validity(cache, addr.set_index, line_index, 1);
  5,829 (0.0%)      victim->tag = addr.tag;
  3,886 (0.0%)      victim->LRU = 0;
  3,886 (0.0%)      if (received_cache_line_from_child != NULL) {
 13,851 (0.0%)          change_dirtiness(cache, addr.set_index, line_index, received_cache_line_from_child->dirty);
 12,312 (0.0%)          Address_t addr_in_child = get_address(cache->child_cache, addr.full_addr); 
 23,085 (0.0%)          change_dirtiness(cache->child_cache, addr_in_child.set_index, get_line_index_from_tag(cache->child_cache, addr_in_child), 0);
      .                 //received_cache_line_from_child->dirty = false; // make sure only the 'top level' version of this line is dirty
      .             }
      .             // copy and insert block
 17,487 (0.0%)      memcpy(victim->block, block, cache->block_size);
  5,829 (0.0%)  }
      .         
      .         // NOTE: This function assumes that cache inclusivity holds
  2,870 (0.0%)  void cache_writeback_block(Cache_t* cache, int addr_int, char* data, size_t block_size) {
      .         
  2,870 (0.0%)      Address_t addr = get_address(cache, addr_int);
      .         
      .             // If inclusivity holds, we will always find a line in this set with a matching tag
  2,870 (0.0%)      int line_index = get_line_index_from_tag(cache, addr);
      .         
    820 (0.0%)      if (line_index == -1) {
      .                 printf("ERROR: Tried to perform write-back, but block was missing in lower level cache. Cache inclusivity didn't hold.\n");
      .                 printf("We were trying to insert tag %x into L%d\n", addr.tag, cache->layer+1);
      .                 exit(1);
      .             }
  5,330 (0.0%)      fprintf(CACHE_LOG, "E %d %d %d\n", cache->layer+1, addr.set_index, line_index);
      .         
  6,560 (0.0%)      char* block = cache->sets[addr.set_index][line_index].block;
      .         
      .             // TODO: Modify this such that we index in with the proper blockoffset in case the block sizes don't match
  2,460 (0.0%)      memcpy(block, data, block_size);
      .         
      .             // we only write back if the block is dirty, so the we also have to mark this line dirty
  2,870 (0.0%)      change_dirtiness(cache, addr.set_index, line_index, 1);
      .             //cache->sets[addr.set_index][line_index].dirty = true;
  1,230 (0.0%)  }
      .         
111,290 (0.2%)  int get_line_index_from_tag(Cache_t* cache, Address_t addr) {
 89,839 (0.1%)      for (uint32_t i = 0; i < cache->associativity; i++) {
459,276 (0.6%)          if (cache->sets[addr.set_index][i].valid && cache->sets[addr.set_index][i].tag == addr.tag) {return i;}
      .             }
  2,330 (0.0%)      return -1;
 22,258 (0.0%)  }
      .         
 19,430 (0.0%)  int get_replacement_line_index(Cache_t* cache, uint32_t set_index) {
 27,202 (0.0%)      CacheLine_t* set = cache->sets[set_index];
      .             // first check if there's room anywhere.
  3,886 (0.0%)      int line_index = -1;
 46,726 (0.1%)      for (uint32_t i = 0; i < cache->associativity; i++) {
 56,856 (0.1%)          if (!set[i].valid) {
    112 (0.0%)              line_index = i;
     56 (0.0%)              break;
      .                 }
      .             }
      .         
      .             // if no room, find room based on replacement policy
  7,772 (0.0%)      if (line_index == -1) {
 11,490 (0.0%)          switch (ACTIVE_REPLACEMENT_POLICY) {
      .                     case LRU_REPLACEMENT_POLICY:
  3,830 (0.0%)                  uint32_t maxval = 0;
 46,150 (0.1%)                  for (uint32_t i = 0; i < cache->associativity; i++) {
 50,974 (0.1%)                      if (set[i].LRU >= maxval) {
  8,456 (0.0%)                          line_index = i;
 42,280 (0.1%)                          maxval = set[i].LRU;
      .                             }
      .                         }
  3,830 (0.0%)                  break;
      .                     case RANDOM_REPLACEMENT_POLICY:
      .                         line_index = 0;
      .                         break;
      .                     default: break;
      .                 }
      .             }
      .         
  7,772 (0.0%)      if (line_index == -1) {
      .                 printf("ERROR: Couldn't find line in L%d to mark as victim.\n", cache->layer+1);
      .                 exit(1);
      .             }
      .         
  3,886 (0.0%)      return line_index;
  7,772 (0.0%)  }
      .         
  4,011 (0.0%)  void evict_cache_line(Cache_t* cache, uint32_t addr_int, CacheLine_t* evict_line, struct memory *mem) {
  4,011 (0.0%)      Address_t addr = get_address(cache, addr_int);
  7,449 (0.0%)      change_dirtiness(cache, addr.set_index, get_line_index_from_tag(cache, addr), 0);
      .             //evict_line->dirty = false;
  2,292 (0.0%)      if (cache->child_cache == NULL) { // Writing to main memory
  1,304 (0.0%)          memory_write_back(mem, addr_int, evict_line->block, cache->block_size);
      .             } else { // Writing to cache
  4,100 (0.0%)          cache_writeback_block(cache->child_cache, addr_int, evict_line->block, cache->block_size);
      .             }
  1,882 (0.0%)  }
      .         
  2,340 (0.0%)  void invalidate_line(Cache_t* cache, uint32_t addr_int, struct memory* mem) {
  2,730 (0.0%)      Address_t addr = get_address(cache, addr_int);
      .         
  2,730 (0.0%)      int line_index = get_line_index_from_tag(cache, addr);
    780 (0.0%)      if (line_index != -1) {
     45 (0.0%)          CacheLine_t* victim = &cache->sets[addr.set_index][line_index];
     12 (0.0%)          if (victim->dirty) {
      .                     //victim->dirty = false;
      7 (0.0%)              change_dirtiness(cache, addr.set_index, line_index, 0);
     18 (0.0%)              uint32_t evict_addr = (victim->tag << (cache->set_bit_length + cache->block_offset_bit_length)) | (addr.set_index << cache->block_offset_bit_length);
     21 (0.0%)              evict_cache_line(cache, evict_addr, &cache->sets[addr.set_index][line_index], mem);
      .                 }
      .                 // Back-invalidation up the cache chain
     12 (0.0%)          if (cache->parent_cache != NULL) {
      7 (0.0%)              invalidate_line(cache->parent_cache, addr_int, mem);
      .                 }
      .         
     21 (0.0%)          change_validity(cache, addr.set_index, line_index, 0);
      .             }
  1,170 (0.0%)  }
      .         
 30,288 (0.0%)  void increment_line_LRU(Cache_t* cache, uint32_t setIndex) {
 91,217 (0.1%)      for (uint32_t i = 0; i < cache->associativity; i++) {
137,355 (0.2%)          cache->sets[setIndex][i].LRU++;
      .             }
 30,288 (0.0%)  }
      .         
    189 (0.0%)  void CacheSetToString(Cache_t* cache, int setIndex, char* out) {
  1,155 (0.0%)      char holder[400] = {0};
      .         
    476 (0.0%)      for (uint32_t i = 0; i < cache->associativity; i++) {
    490 (0.0%)          char buf[50] = {0};
    420 (0.0%)          CacheLineToString(cache, setIndex, i, buf);
    350 (0.0%)          strcat(holder, buf);
      .             }
      .         
    147 (0.0%)      sprintf(out, "Set %02d |%s\n", setIndex, holder);
    126 (0.0%)  }
      .         
    490 (0.0%)  void CacheLineToString(Cache_t* cache, uint32_t setIndex, uint32_t lineIndex, char* out) {
      .             
  1,260 (0.0%)      CacheLine_t cacheLine = cache->sets[setIndex][lineIndex];
      .         
      .         
    490 (0.0%)      char* tag = malloc(1 + cache->tag_bit_length * sizeof(char));
 10,220 (0.0%)      for (uint32_t i = 0; i < cache->tag_bit_length; i++) {
 19,600 (0.0%)          int shft = (cacheLine.tag >> (cache->tag_bit_length-i-1)) & 0b1;
 13,780 (0.0%)          tag[i] = shft ? '1' : '0';
      .             }
    420 (0.0%)      tag[cache->tag_bit_length] = 0;
      .         
    910 (0.0%)      sprintf(out, " (V:%d) (D:%d) (T:%s) (LRU:%d) |", cacheLine.valid, cacheLine.dirty, tag, cacheLine.LRU);
      .             
    210 (0.0%)      free(tag);
    210 (0.0%)  }
      .         
    168 (0.0%)  void PrintSet(Cache_t* cache, uint32_t setIndex) {
  1,155 (0.0%)      char buff[400] = {0};
    126 (0.0%)      CacheSetToString(cache, setIndex, buff);
    126 (0.0%)      printf("%s", buff);
    126 (0.0%)  }
      .         
     84 (0.0%)  void PrintCache(Cache_t* cache) {
    231 (0.0%)      for (uint32_t i = 0; i < cache->set_count; i++) {
    105 (0.0%)          PrintSet(cache, i);
      .             }
     84 (0.0%)  }
      .         
     24 (0.0%)  Cache_t* parse_cpu(char* path) {
     18 (0.0%)      FILE* file = fopen(path, "r");
      6 (0.0%)      if (!file) {
      .                 printf("ERROR: Couldn't find file: '%s' when trying to parse a CPU architecture", path);
      .                 exit(1);
      .             }
     12 (0.0%)      char buf[32] = {0};
     15 (0.0%)      fgets(buf, sizeof(buf), file);
     12 (0.0%)      N_CACHE_LEVELS = (uint32_t)atoi(buf);
     15 (0.0%)      memset(buf, 0, sizeof(buf));
      .             
      .             // Logging info about the general cache architecture
     18 (0.0%)      caches = malloc(N_CACHE_LEVELS * (sizeof(Cache_t)));
      .         
      .             // Storage variables for:
      .             // Cache size: 2^p * q
      .             // Block size: 2^k
      .             // Associativity: a-way
      .             uint32_t p, q, k, a;
      .         
      .         
     15 (0.0%)      memset(buf, 0, sizeof(buf));
      .         
     15 (0.0%)      fgets(buf, sizeof(buf), file); // name
     21 (0.0%)      if (strcmp(buf, "i\n")) { // IF NOT EQUALS
     33 (0.0%)          fseek(file, (long)-strlen(buf), SEEK_CUR);
      .             }
      .             else {
      .                 memset(buf, 0, sizeof(buf));
      .                 fgets(buf, sizeof(buf), file); // p
      .                 p = atoi(buf);
      .                 memset(buf, 0, sizeof(buf));
      .                 fgets(buf, sizeof(buf), file); // q
      .                 q = atoi(buf);
-- line 404 ----------------------------------------
-- line 409 ----------------------------------------
      .                 fgets(buf, sizeof(buf), file); // associativity
      .                 a = atoi(buf);
      .                 memset(buf, 0, sizeof(buf));
      .         
      .                 //printf("%d, %d, %d, %d\n", p, q, k, a);
      .                 L1i = cache_new(0, (uint32_t)(pow(2,p) * q), (uint32_t)(pow(2,k)), a);
      .             }
      .         
     43 (0.0%)      for (uint32_t i = 0; i < N_CACHE_LEVELS; i++) {
     35 (0.0%)          fgets(buf, sizeof(buf), file); // Name
     35 (0.0%)          memset(buf, 0, sizeof(buf));
     35 (0.0%)          fgets(buf, sizeof(buf), file); // p
     28 (0.0%)          p = atoi(buf);
     35 (0.0%)          memset(buf, 0, sizeof(buf));
     35 (0.0%)          fgets(buf, sizeof(buf), file); // q
     28 (0.0%)          q = atoi(buf);
     35 (0.0%)          memset(buf, 0, sizeof(buf));
     35 (0.0%)          fgets(buf, sizeof(buf), file); // k
     28 (0.0%)          k = atoi(buf);
     35 (0.0%)          memset(buf, 0, sizeof(buf));
     35 (0.0%)          fgets(buf, sizeof(buf), file); // associativity
     28 (0.0%)          a = atoi(buf);
     35 (0.0%)          memset(buf, 0, sizeof(buf));
      .         
      .                 //printf("%d, %d, %d, %d\n", p, q, k, a);
    392 (0.0%)          caches[i] = *cache_new(i, (uint32_t)(pow(2,p) * q), (uint32_t)(pow(2,k)), a);
     14 (0.0%)          if (i > 0) { // linked list
     44 (0.0%)              caches[i-1].child_cache = &caches[i];
     44 (0.0%)              caches[i].parent_cache = &caches[i-1];
      .                 }
      .             }
     18 (0.0%)      if (N_CACHE_LEVELS > 1 && L1i != NULL) {
      .                 L1i->child_cache = &caches[1]; // set L2 as child of instruction cache L1i
      .             }
      .         
      9 (0.0%)      fclose(file);
      3 (0.0%)      return caches;
     18 (0.0%)  }
      .         
      .         
 66,068 (0.1%)  Address_t get_address(Cache_t* cache, uint32_t address) {
      .             
      .             Address_t ad;
 33,034 (0.0%)      ad.full_addr = address;
      .         
      .             uint32_t mask;
      .             // block offset
 16,517 (0.0%)      mask = ~0;
 66,068 (0.1%)      mask = mask << cache->block_offset_bit_length;
 16,517 (0.0%)      mask = ~mask;
 49,551 (0.1%)      ad.block_offset = address & mask;
      .         
      .             // set index
 66,068 (0.1%)      address = address >> cache->block_offset_bit_length;
 16,517 (0.0%)      mask = ~0;
 66,068 (0.1%)      mask = mask << cache->set_bit_length;
 16,517 (0.0%)      mask = ~mask;
 49,551 (0.1%)      ad.set_index = address & mask;
      .         
      .             // tag
 66,068 (0.1%)      address = address >> cache->set_bit_length;
 16,517 (0.0%)      mask = ~0;
 66,068 (0.1%)      mask = mask << cache->tag_bit_length;
 16,517 (0.0%)      mask = ~mask;
 49,551 (0.1%)      ad.tag = address & mask;
      .         
 33,034 (0.0%)      return ad;
 33,034 (0.0%)  }
      .         
      .         
     77 (0.0%)  Cache_t* cache_new(uint32_t layer, uint32_t cacheSize, uint32_t block_size, uint32_t associativity) {
     21 (0.0%)      Cache_t* c = (Cache_t*)malloc(sizeof(Cache_t));
     21 (0.0%)      c->layer = layer;
     21 (0.0%)      c->cache_size = cacheSize;
     21 (0.0%)      c->block_size = block_size;
     21 (0.0%)      c->associativity = associativity;
     91 (0.0%)      c->set_count = (c->cache_size / (c->associativity * c->block_size));
      .         
    105 (0.0%)      c->block_offset_bit_length = log2(c->block_size);
    105 (0.0%)      c->set_bit_length = log2(c->set_count);
     70 (0.0%)      c->tag_bit_length = ADDR_LEN - c->block_offset_bit_length - c->set_bit_length;
      .         
     14 (0.0%)      c->child_cache = NULL; // THIS HAS TO BE SET ELSEWHERE
     14 (0.0%)      c->parent_cache = NULL; // THIS HAS TO BE SET ELSEWHERE
      .            
     63 (0.0%)      c->sets = (CacheLine_t**)malloc(c->set_count * sizeof(CacheLine_t*));
    107 (0.0%)      for (uint32_t i = 0; i < c->set_count; i++) {
    208 (0.0%)          c->sets[i] = (CacheLine_t*)malloc(c->associativity * sizeof(CacheLine_t));
    218 (0.0%)          for (uint32_t j = 0; j < c->associativity; j++) {
    700 (0.0%)              c->sets[i][j] = cacheline_new(malloc(block_size * sizeof(char)));
      .                 };
      .             };
      .         
      7 (0.0%)      return c;
     42 (0.0%)  }
      .         
    112 (0.0%)  CacheLine_t cacheline_new(char* block) {
      .             CacheLine_t l;
     28 (0.0%)      l.valid = 0;
     28 (0.0%)      l.dirty = 0;
     28 (0.0%)      l.LRU = 0;
     28 (0.0%)      l.tag = 0;
     56 (0.0%)      l.block = block;
    196 (0.0%)      return l;
     84 (0.0%)  }
      .         
      6 (0.0%)  void start_cache_log() {
     18 (0.0%)      CACHE_LOG = fopen("cache_log", "w");
      9 (0.0%)  }
      .         
      .         // Returns amount of cycles spent on memory accesses
      6 (0.0%)  void stop_cache_log() {
      9 (0.0%)      fclose(CACHE_LOG);
      9 (0.0%)  }
      .         
      5 (0.0%)  FILE* get_cache_log() {return CACHE_LOG;}
      .         
     21 (0.0%)  void print_all_caches() {
     21 (0.0%)      printf("\n\n");
    119 (0.0%)      for (uint32_t i = 0; i < N_CACHE_LEVELS; i++) {
    147 (0.0%)          printf("L%d:\n", i+1);
    126 (0.0%)          PrintCache(&caches[i]);
     42 (0.0%)          printf("\n");
      .             }
     28 (0.0%)  }
      .         
 15,568 (0.0%)  void change_validity(Cache_t* cache, int set_index, int line_index, bool new_validity) {
  3,892 (0.0%)      if (new_validity == 1) {
 27,202 (0.0%)          fprintf(CACHE_LOG, "V %d %d %d\n", cache->layer+1, set_index, line_index);
      .             } else {
     39 (0.0%)          fprintf(CACHE_LOG, "IV %d %d %d\n", cache->layer+1, set_index, line_index);
      .             }
 31,136 (0.0%)      cache->sets[set_index][line_index].valid = new_validity;
      .         
  7,781 (0.0%)      uint32_t operation_int = new_validity ? 1 : 2;
 13,622 (0.0%)      uint32_t cache_int = cache == L1i ? cache->layer : cache->layer+1;
 11,676 (0.0%)      add_operation_to_checksum(operation_int, cache_int, set_index, line_index);
  5,838 (0.0%)  }
      .         
 37,656 (0.1%)  void change_dirtiness(Cache_t* cache, int set_index, int line_index, bool new_dirty) {
  9,414 (0.0%)      if (new_dirty == 1) {
 18,172 (0.0%)          fprintf(CACHE_LOG, "D %d %d %d\n", cache->layer+1, set_index, line_index);
      .             } else {
 44,317 (0.1%)          fprintf(CACHE_LOG, "C %d %d %d\n", cache->layer+1, set_index, line_index);
      .             }
 75,312 (0.1%)      cache->sets[set_index][line_index].dirty = new_dirty;
      .         
 15,419 (0.0%)      uint32_t operation_int = new_dirty ? 3 : 4;
 32,949 (0.0%)      uint32_t cache_int = cache == L1i ? cache->layer : cache->layer+1;
 28,242 (0.0%)      add_operation_to_checksum(operation_int, cache_int, set_index, line_index);
 14,121 (0.0%)  }
      .         
      .         
 39,918 (0.1%)  void add_operation_to_checksum(uint32_t type, uint32_t cache_idx, uint32_t set_idx, uint32_t line_idx) {
119,754 (0.2%)      cache_checksum += type * 10 + cache_idx * 100 + set_idx * 1000 + line_idx * 10000;
 19,959 (0.0%)  }
      .         
 23,690 (0.0%)  uint32_t get_cache_checksum() {return cache_checksum;}
      .         void set_cache_checksum(uint32_t v) {cache_checksum = v;

--------------------------------------------------------------------------------
-- Annotated source file: /home/zupreme/Documents/University/TheMemoryHole/engine/hashmap/hashmap.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 59 ----------------------------------------
      .             void *spare;
      .             void *edata;
      .         };
      .         
      .         void hashmap_set_grow_by_power(struct hashmap *map, size_t power) {
      .             map->growpower = power < 1 ? 1 : power > 16 ? 16 : power;
      .         }
      .         
      8 (0.0%)  static double clamp_load_factor(double factor, double default_factor) {
      .             // Check for NaN and clamp between 50% and 90%
      8 (0.0%)      return factor != factor ? default_factor : 
      6 (0.0%)             factor < 0.50 ? 0.50 : 
      8 (0.0%)             factor > 0.95 ? 0.95 : 
      .                    factor;
      4 (0.0%)  }
      .         
      .         void hashmap_set_load_factor(struct hashmap *map, double factor) {
      .             factor = clamp_load_factor(factor, map->loadfactor / 100.0);
      .             map->loadfactor = factor * 100;
      .             map->growat = map->nbuckets * (map->loadfactor / 100.0);
      .         }
      .         
 41,525 (0.1%)  static struct bucket *bucket_at0(void *buckets, size_t bucketsz, size_t i) {
 41,525 (0.1%)      return (struct bucket*)(((char*)buckets)+(bucketsz*i));
 16,610 (0.0%)  }
      .         
 41,525 (0.1%)  static struct bucket *bucket_at(struct hashmap *map, size_t index) {
 66,440 (0.1%)      return bucket_at0(map->buckets, map->bucketsz, index);
 16,610 (0.0%)  }
      .         
 11,706 (0.0%)  static void *bucket_item(struct bucket *entry) {
  7,804 (0.0%)      return ((char*)entry)+sizeof(struct bucket);
  7,804 (0.0%)  }
      .         
 28,530 (0.0%)  static uint64_t clip_hash(uint64_t hash) {
 19,020 (0.0%)      return hash & 0xFFFFFFFFFFFF;
 19,020 (0.0%)  }
      .         
 23,775 (0.0%)  static uint64_t get_hash(struct hashmap *map, const void *key) {
 57,060 (0.1%)      return clip_hash(map->hash(key, map->seed0, map->seed1));
  9,510 (0.0%)  }
      .         
      .         
      .         // hashmap_new_with_allocator returns a new hash map using a custom allocator.
      .         // See hashmap_new for more information information
      .         struct hashmap *hashmap_new_with_allocator(void *(*_malloc)(size_t), 
      .             void *(*_realloc)(void*, size_t), void (*_free)(void*),
      .             size_t elsize, size_t cap, uint64_t seed0, uint64_t seed1,
      .             uint64_t (*hash)(const void *item, uint64_t seed0, uint64_t seed1),
      .             int (*compare)(const void *a, const void *b, void *udata),
      .             void (*elfree)(void *item),
      .             void *udata)
     18 (0.0%)  {
     12 (0.0%)      _malloc = _malloc ? _malloc : __malloc ? __malloc : malloc;
     12 (0.0%)      _realloc = _realloc ? _realloc : __realloc ? __realloc : realloc;
     12 (0.0%)      _free = _free ? _free : __free ? __free : free;
      2 (0.0%)      size_t ncap = 16;
      6 (0.0%)      if (cap < ncap) {
      3 (0.0%)          cap = ncap;
      .             } else {
      6 (0.0%)          while (ncap < cap) {
      1 (0.0%)              ncap *= 2;
      .                 }
      2 (0.0%)          cap = ncap;
      .             }
      6 (0.0%)      size_t bucketsz = sizeof(struct bucket) + elsize;
     42 (0.0%)      while (bucketsz & (sizeof(uintptr_t)-1)) {
      8 (0.0%)          bucketsz++;
      .             }
      .             // hashmap + spare + edata
      8 (0.0%)      size_t size = sizeof(struct hashmap)+bucketsz*2;
     10 (0.0%)      struct hashmap *map = _malloc(size);
      4 (0.0%)      if (!map) {
      .                 return NULL;
      .             }
     10 (0.0%)      memset(map, 0, sizeof(struct hashmap));
      6 (0.0%)      map->elsize = elsize;
      6 (0.0%)      map->bucketsz = bucketsz;
      6 (0.0%)      map->seed0 = seed0;
      6 (0.0%)      map->seed1 = seed1;
      6 (0.0%)      map->hash = hash;
      6 (0.0%)      map->compare = compare;
      6 (0.0%)      map->elfree = elfree;
      6 (0.0%)      map->udata = udata;
      8 (0.0%)      map->spare = ((char*)map)+sizeof(struct hashmap);
     12 (0.0%)      map->edata = (char*)map->spare+bucketsz;
      6 (0.0%)      map->cap = cap;
      6 (0.0%)      map->nbuckets = cap;
     10 (0.0%)      map->mask = map->nbuckets-1;
     20 (0.0%)      map->buckets = _malloc(map->bucketsz*map->nbuckets);
      8 (0.0%)      if (!map->buckets) {
      .                 _free(map);
      .                 return NULL;
      .             }
     20 (0.0%)      memset(map->buckets, 0, map->bucketsz*map->nbuckets);
      4 (0.0%)      map->growpower = 1;
     22 (0.0%)      map->loadfactor = clamp_load_factor(HASHMAP_LOAD_FACTOR, GROW_AT) * 100;
     42 (0.0%)      map->growat = map->nbuckets * (map->loadfactor / 100.0);
     30 (0.0%)      map->shrinkat = map->nbuckets * SHRINK_AT;
      6 (0.0%)      map->malloc = _malloc;
      6 (0.0%)      map->realloc = _realloc;
      6 (0.0%)      map->free = _free;
      2 (0.0%)      return map;  
      4 (0.0%)  }
      .         
      .         // hashmap_new returns a new hash map. 
      .         // Param `elsize` is the size of each element in the tree. Every element that
      .         // is inserted, deleted, or retrieved will be this size.
      .         // Param `cap` is the default lower capacity of the hashmap. Setting this to
      .         // zero will default to 16.
      .         // Params `seed0` and `seed1` are optional seed values that are passed to the 
      .         // following `hash` function. These can be any value you wish but it's often 
-- line 170 ----------------------------------------
-- line 179 ----------------------------------------
      .         // Param `elfree` is a function that frees a specific item. This should be NULL
      .         // unless you're storing some kind of reference data in the hash.
      .         struct hashmap *hashmap_new(size_t elsize, size_t cap, uint64_t seed0, 
      .             uint64_t seed1,
      .             uint64_t (*hash)(const void *item, uint64_t seed0, uint64_t seed1),
      .             int (*compare)(const void *a, const void *b, void *udata),
      .             void (*elfree)(void *item),
      .             void *udata)
      9 (0.0%)  {
     17 (0.0%)      return hashmap_new_with_allocator(NULL, NULL, NULL, elsize, cap, seed0, 
      .                 seed1, hash, compare, elfree, udata);
      2 (0.0%)  }
      .         
      .         static void free_elements(struct hashmap *map) {
      .             if (map->elfree) {
      .                 for (size_t i = 0; i < map->nbuckets; i++) {
      .                     struct bucket *bucket = bucket_at(map, i);
      .                     if (bucket->dib) map->elfree(bucket_item(bucket));
      .                 }
      .             }
-- line 198 ----------------------------------------
-- line 218 ----------------------------------------
      .                 map->nbuckets = map->cap;
      .             }
      .             memset(map->buckets, 0, map->bucketsz*map->nbuckets);
      .             map->mask = map->nbuckets-1;
      .             map->growat = map->nbuckets * (map->loadfactor / 100.0) ;
      .             map->shrinkat = map->nbuckets * SHRINK_AT;
      .         }
      .         
      7 (0.0%)  static bool resize0(struct hashmap *map, size_t new_cap) {
     33 (0.0%)      struct hashmap *map2 = hashmap_new_with_allocator(map->malloc, map->realloc, 
      .                 map->free, map->elsize, new_cap, map->seed0, map->seed1, map->hash, 
      .                 map->compare, map->elfree, map->udata);
      2 (0.0%)      if (!map2) return false;
     86 (0.0%)      for (size_t i = 0; i < map->nbuckets; i++) {
     96 (0.0%)          struct bucket *entry = bucket_at(map, i);
     64 (0.0%)          if (!entry->dib) {
      7 (0.0%)              continue;
      .                 }
     18 (0.0%)          entry->dib = 1;
     81 (0.0%)          size_t j = entry->hash & map2->mask;
      1 (0.0%)          while(1) {
     60 (0.0%)              struct bucket *bucket = bucket_at(map2, j);
     40 (0.0%)              if (bucket->dib == 0) {
     63 (0.0%)                  memcpy(bucket, entry, map->bucketsz);
      9 (0.0%)                  break;
      .                     }
      6 (0.0%)              if (bucket->dib < entry->dib) {
      .                         memcpy(map2->spare, bucket, map->bucketsz);
      .                         memcpy(bucket, entry, map->bucketsz);
      .                         memcpy(entry, map2->spare, map->bucketsz);
      .                     }
      6 (0.0%)              j = (j + 1) & map2->mask;
      5 (0.0%)              entry->dib += 1;
      .                 }
      .             }
      6 (0.0%)      map->free(map->buckets);
      4 (0.0%)      map->buckets = map2->buckets;
      4 (0.0%)      map->nbuckets = map2->nbuckets;
      4 (0.0%)      map->mask = map2->mask;
      4 (0.0%)      map->growat = map2->growat;
      4 (0.0%)      map->shrinkat = map2->shrinkat;
      5 (0.0%)      map->free(map2);
      1 (0.0%)      return true;
      5 (0.0%)  }
      .         
      5 (0.0%)  static bool resize(struct hashmap *map, size_t new_cap) {
      5 (0.0%)      return resize0(map, new_cap);
      2 (0.0%)  }
      .         
      .         // hashmap_set_with_hash works like hashmap_set but you provide your
      .         // own hash. The 'hash' callback provided to the hashmap_new function
      .         // will not be called
      .         const void *hashmap_set_with_hash(struct hashmap *map, const void *item,
      .             uint64_t hash)
    102 (0.0%)  {
     68 (0.0%)      hash = clip_hash(hash);
     34 (0.0%)      map->oom = false;
    102 (0.0%)      if (map->count >= map->growat) {
     18 (0.0%)          if (!resize(map, map->nbuckets*(1<<map->growpower))) {
      .                     map->oom = true;
      .                     return NULL;
      .                 }
      .             }
      .         
     51 (0.0%)      struct bucket *entry = map->edata;
    187 (0.0%)      entry->hash = hash;
     34 (0.0%)      entry->dib = 1;
     68 (0.0%)      void *eitem = bucket_item(entry);
    119 (0.0%)      memcpy(eitem, item, map->elsize);
      .         
      .             void *bitem;
    153 (0.0%)      size_t i = entry->hash & map->mask;
     13 (0.0%)      while(1) {
    180 (0.0%)          struct bucket *bucket = bucket_at(map, i);
    120 (0.0%)          if (bucket->dib == 0) {
    119 (0.0%)              memcpy(bucket, entry, map->bucketsz);
     85 (0.0%)              map->count++;
     34 (0.0%)              return NULL;
      .                 }
     52 (0.0%)          bitem = bucket_item(bucket);
    117 (0.0%)          if (entry->hash == bucket->hash && (!map->compare ||
      .                     map->compare(eitem, bitem, map->udata) == 0))
      .                 {
      .                     memcpy(map->spare, bitem, map->elsize);
      .                     memcpy(bitem, eitem, map->elsize);
      .                     return map->spare;
      .                 }
     78 (0.0%)          if (bucket->dib < entry->dib) {
     40 (0.0%)              memcpy(map->spare, bucket, map->bucketsz);
     35 (0.0%)              memcpy(bucket, entry, map->bucketsz);
     40 (0.0%)              memcpy(entry, map->spare, map->bucketsz);
     20 (0.0%)              eitem = bucket_item(entry);
      .                 }
     78 (0.0%)          i = (i + 1) & map->mask;
     65 (0.0%)          entry->dib += 1;
      .             }
     34 (0.0%)  }
      .         
      .         // hashmap_set inserts or replaces an item in the hash map. If an item is
      .         // replaced then it is returned otherwise NULL is returned. This operation
      .         // may allocate memory. If the system is unable to allocate additional
      .         // memory then NULL is returned and hashmap_oom() returns true.
     85 (0.0%)  const void *hashmap_set(struct hashmap *map, const void *item) {
    187 (0.0%)      return hashmap_set_with_hash(map, item, get_hash(map, item));
     34 (0.0%)  }
      .         
      .         // hashmap_get_with_hash works like hashmap_get but you provide your
      .         // own hash. The 'hash' callback provided to the hashmap_new function
      .         // will not be called
      .         const void *hashmap_get_with_hash(struct hashmap *map, const void *key, 
      .             uint64_t hash)
 28,428 (0.0%)  {
 18,952 (0.0%)      hash = clip_hash(hash);
 18,952 (0.0%)      size_t i = hash & map->mask;
  3,511 (0.0%)      while(1) {
 49,494 (0.1%)          struct bucket *bucket = bucket_at(map, i);
 34,738 (0.0%)          if (!bucket->dib) return NULL;
 44,268 (0.1%)          if (bucket->hash == hash) {
 15,468 (0.0%)              void *bitem = bucket_item(bucket);
 58,005 (0.1%)              if (!map->compare || map->compare(key, bitem, map->udata) == 0) {
  7,734 (0.0%)                  return bitem;
      .                     }
      .                 }
 21,066 (0.0%)          i = (i + 1) & map->mask;
      .             }
  9,476 (0.0%)  }
      .         
      .         // hashmap_get returns the item based on the provided key. If the item is not
      .         // found then NULL is returned.
 23,690 (0.0%)  const void *hashmap_get(struct hashmap *map, const void *key) {
 52,118 (0.1%)      return hashmap_get_with_hash(map, key, get_hash(map, key));
  9,476 (0.0%)  }
      .         
      .         // hashmap_probe returns the item in the bucket at position or NULL if an item
      .         // is not set for that bucket. The position is 'moduloed' by the number of 
      .         // buckets in the hashmap.
      .         const void *hashmap_probe(struct hashmap *map, uint64_t position) {
      .             size_t i = position & map->mask;
      .             struct bucket *bucket = bucket_at(map, i);
      .             if (!bucket->dib) {
-- line 357 ----------------------------------------
-- line 490 ----------------------------------------
      .         // You should have received a copy of the CC0 Public Domain Dedication along
      .         // with this software. If not, see
      .         // <http://creativecommons.org/publicdomain/zero/1.0/>.
      .         //
      .         // default: SipHash-2-4
      .         //-----------------------------------------------------------------------------
      .         static uint64_t SIP64(const uint8_t *in, const size_t inlen, uint64_t seed0,
      .             uint64_t seed1) 
 47,550 (0.1%)  {
      .         #define U8TO64_LE(p) \
      .             {  (((uint64_t)((p)[0])) | ((uint64_t)((p)[1]) << 8) | \
      .                 ((uint64_t)((p)[2]) << 16) | ((uint64_t)((p)[3]) << 24) | \
      .                 ((uint64_t)((p)[4]) << 32) | ((uint64_t)((p)[5]) << 40) | \
      .                 ((uint64_t)((p)[6]) << 48) | ((uint64_t)((p)[7]) << 56)) }
      .         #define U64TO8_LE(p, v) \
      .             { U32TO8_LE((p), (uint32_t)((v))); \
      .               U32TO8_LE((p) + 4, (uint32_t)((v) >> 32)); }
-- line 506 ----------------------------------------
-- line 514 ----------------------------------------
      .             { v0 += v1; v1 = ROTL(v1, 13); \
      .               v1 ^= v0; v0 = ROTL(v0, 32); \
      .               v2 += v3; v3 = ROTL(v3, 16); \
      .               v3 ^= v2; \
      .               v0 += v3; v3 = ROTL(v3, 21); \
      .               v3 ^= v0; \
      .               v2 += v1; v1 = ROTL(v1, 17); \
      .               v1 ^= v2; v2 = ROTL(v2, 32); }
218,730 (0.3%)      uint64_t k0 = U8TO64_LE((uint8_t*)&seed0);
218,730 (0.3%)      uint64_t k1 = U8TO64_LE((uint8_t*)&seed1);
 14,265 (0.0%)      uint64_t v3 = UINT64_C(0x7465646279746573) ^ k1;
 14,265 (0.0%)      uint64_t v2 = UINT64_C(0x6c7967656e657261) ^ k0;
 14,265 (0.0%)      uint64_t v1 = UINT64_C(0x646f72616e646f6d) ^ k1;
 14,265 (0.0%)      uint64_t v0 = UINT64_C(0x736f6d6570736575) ^ k0;
 28,530 (0.0%)      const uint8_t *end = in + inlen - (inlen % sizeof(uint64_t));
 19,020 (0.0%)      for (; in != end; in += 8) {
      .                 uint64_t m = U8TO64_LE(in);
      .                 v3 ^= m;
      .                 SIPROUND; SIPROUND;
      .                 v0 ^= m;
      .             }
 14,265 (0.0%)      const int left = inlen & 7;
 14,265 (0.0%)      uint64_t b = ((uint64_t)inlen) << 56;
 47,550 (0.1%)      switch (left) {
      .             case 7: b |= ((uint64_t)in[6]) << 48; /* fall through */
      .             case 6: b |= ((uint64_t)in[5]) << 40; /* fall through */
      .             case 5: b |= ((uint64_t)in[4]) << 32; /* fall through */
 28,530 (0.0%)      case 4: b |= ((uint64_t)in[3]) << 24; /* fall through */
 28,530 (0.0%)      case 3: b |= ((uint64_t)in[2]) << 16; /* fall through */
 28,530 (0.0%)      case 2: b |= ((uint64_t)in[1]) << 8; /* fall through */
 23,775 (0.0%)      case 1: b |= ((uint64_t)in[0]); break;
      .             case 0: break;
      .             }
  9,510 (0.0%)      v3 ^= b;
209,220 (0.3%)      SIPROUND; SIPROUND;
  9,510 (0.0%)      v0 ^= b;
  4,755 (0.0%)      v2 ^= 0xff;
418,440 (0.6%)      SIPROUND; SIPROUND; SIPROUND; SIPROUND;
 23,775 (0.0%)      b = v0 ^ v1 ^ v2 ^ v3;
  4,755 (0.0%)      uint64_t out = 0;
228,240 (0.3%)      U64TO8_LE((uint8_t*)&out, b);
  4,755 (0.0%)      return out;
 23,775 (0.0%)  }
      .         
      .         //-----------------------------------------------------------------------------
      .         // MurmurHash3 was written by Austin Appleby, and is placed in the public
      .         // domain. The author hereby disclaims copyright to this source code.
      .         //
      .         // Murmur3_86_128
      .         //-----------------------------------------------------------------------------
      .         static uint64_t MM86128(const void *key, const int len, uint32_t seed) {
-- line 564 ----------------------------------------
-- line 753 ----------------------------------------
      .             h64 ^= h64 >> 32;
      .         
      .             return h64;
      .         }
      .         
      .         // hashmap_sip returns a hash value for `data` using SipHash-2-4.
      .         uint64_t hashmap_sip(const void *data, size_t len, uint64_t seed0,
      .             uint64_t seed1)
 33,285 (0.0%)  {
 28,530 (0.0%)      return SIP64((uint8_t*)data, len, seed0, seed1);
  9,510 (0.0%)  }
      .         
      .         // hashmap_murmur returns a hash value for `data` using Murmur3_86_128.
      .         uint64_t hashmap_murmur(const void *data, size_t len, uint64_t seed0,
      .             uint64_t seed1)
      .         {
      .             (void)seed1;
      .             return MM86128(data, len, seed0);
      .         }
-- line 771 ----------------------------------------

--------------------------------------------------------------------------------
-- Annotated source file: /home/zupreme/Documents/University/TheMemoryHole/engine/memory.c
--------------------------------------------------------------------------------
Ir______________ 

-- line 3 ----------------------------------------
        .         #include <stdio.h>
        .         #include <math.h>
        .         #include <string.h>
        .         
        .         struct memory {
        .           char *pages[0x10000];
        .         };
        .         
        6 (0.0%)  struct memory *memory_create() {
        .           // When we create our memory, we malloc memory for 16 bits worth of null pointers that could later point to each page start
        9 (0.0%)    return calloc(1, sizeof(struct memory));
        6 (0.0%)  }
        .         
       12 (0.0%)  void memory_delete(struct memory *mem) {
  589,836 (0.8%)    for (int j = 0; j < 0x10000; ++j)
        .           {
1,179,648 (1.6%)      if (mem->pages[j])
       36 (0.0%)        free(mem->pages[j]);
        .           }
        9 (0.0%)    free(mem);
        9 (0.0%)  }
        .         
  103,435 (0.1%)  char *get_page(struct memory *mem, int addr) {
   62,061 (0.1%)    int page_number = (addr >> 16) & 0x0ffff;
  124,122 (0.2%)    if (mem->pages[page_number] == NULL) {
       48 (0.0%)      mem->pages[page_number] = calloc(65536, 1);
        .           }
   82,748 (0.1%)    return mem->pages[page_number];
   41,374 (0.1%)  }
        .         
    2,424 (0.0%)  char* find_block(struct memory *mem, int addr, uint32_t block_size) {
    2,424 (0.0%)    char* page = get_page(mem, addr);
    4,444 (0.0%)    int block_offset_bit_length = (int)log2(block_size);
    3,636 (0.0%)    addr = (addr >> block_offset_bit_length) << block_offset_bit_length; // Masking out block offset bits
    1,212 (0.0%)    int page_offset = addr & 0x0ffff;
    1,616 (0.0%)    return &page[page_offset];
      808 (0.0%)  }
        .         
    1,141 (0.0%)  void memory_write_back(struct memory* mem, int addr, char* block, uint32_t block_size) {
      978 (0.0%)    char* page = get_page(mem, addr);
      489 (0.0%)    int page_offset = addr & 0x0ffff;
    1,467 (0.0%)    memcpy(&page[page_offset], block, block_size);
      489 (0.0%)  }
        .         
        .         
        .         void memory_wr_w(struct memory *mem, int addr, uint32_t data)
    1,776 (0.0%)  {
    1,776 (0.0%)    char* page = get_page(mem, addr);
      888 (0.0%)    int page_offset = addr & 0x0ffff;
    1,776 (0.0%)    memcpy(&page[page_offset], &data, sizeof(uint32_t));
      888 (0.0%)  }
        .         
        .         void memory_wr_h(struct memory *mem, int addr, uint16_t data)
        .         {
        .           char* page = get_page(mem, addr);
        .           int page_offset = addr & 0x0ffff;
        .           memcpy(&page[page_offset], &data, sizeof(uint16_t));
        .         }
        .         
        .         void memory_wr_b(struct memory *mem, int addr, uint8_t data)
  138,768 (0.2%)  {
  118,944 (0.2%)    char* page = get_page(mem, addr);
   59,472 (0.1%)    int page_offset = addr & 0x0ffff;
  118,944 (0.2%)    memcpy(&page[page_offset], &data, sizeof(uint8_t));
   59,472 (0.1%)  

--------------------------------------------------------------------------------
-- Annotated source file: /home/zupreme/Documents/University/TheMemoryHole/engine/mmu.c
--------------------------------------------------------------------------------
Ir____________ 

      .         #include "mmu.h"
      .         #include "memory.h"
      .         #include <stdio.h>
      .         #include <stdint.h>
      .         
      .         struct memory* mem;
      .         FILE* accesses;
      .         
      2 (0.0%)  void open_accesses_file() {
      6 (0.0%)      accesses = fopen("accesses", "a");
      3 (0.0%)  }
      2 (0.0%)  void close_accesses_file() {
      3 (0.0%)      fclose(accesses);
      3 (0.0%)  }
      .         
  9,476 (0.0%)  uint32_t mmu_get_checksum() {
  9,476 (0.0%)      return get_cache_checksum();
  9,476 (0.0%)  }
      .         
  1,776 (0.0%)  void mmu_wr_w_instr(struct memory *mem, int addr, uint32_t data) {
      .             
      .             //fprintf(accesses, "mmu_wr_w_instr(memory, 0x%x, %d);\n", addr, data);
  1,184 (0.0%)      if (addr & 0b11)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
  1,776 (0.0%)      memory_wr_w(mem, addr, data);
    888 (0.0%)  }
      .         
      .         void mmu_wr_h_instr(struct memory *mem, int addr, uint16_t data) {
      .             //fprintf(accesses, "mmu_wr_h_instr(memory, 0x%x, %d);\n", addr, data);
      .             if (addr & 0b1)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
      .             memory_wr_h(mem, addr, data);
      .         }
      .         
138,768 (0.2%)  void mmu_wr_b_instr(struct memory *mem, int addr, uint8_t data) {
      .             //fprintf(accesses, "mmu_wr_b_instr(memory, 0x%x, %d);\n", addr, data);
118,944 (0.2%)      memory_wr_b(mem, addr, data);
 59,472 (0.1%)  }
      .         
  3,834 (0.0%)  void mmu_wr_w(struct memory *mem, int addr, uint32_t data) {
      .             //fprintf(accesses, "mmu_wr_w(memory, 0x%x, %d);\n", addr, data);
  2,556 (0.0%)      if (addr & 0b11)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
  3,834 (0.0%)      cache_wr_w(mem, addr, data);
  1,917 (0.0%)  }
      .         
      .         void mmu_wr_h(struct memory *mem, int addr, uint16_t data) {
      .             //fprintf(accesses, "mmu_wr_h(memory, 0x%x, %d);\n", addr, data);
      .             if (addr & 0b1)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
      .             cache_wr_h(mem, addr, data);
      .         }
      .         
     42 (0.0%)  void mmu_wr_b(struct memory *mem, int addr, uint8_t data) {
      .             //fprintf(accesses, "mmu_wr_b(memory, 0x%x, %d);\n", addr, data);
     36 (0.0%)      cache_wr_b(mem, addr, data);
     18 (0.0%)  }
      .         
 23,695 (0.0%)  int mmu_rd_instr(struct memory *mem, int addr) {
      .             //fprintf(accesses, "mmu_rd_instr(memory, 0x%x);\n", addr);
 18,956 (0.0%)      if (addr & 0b11)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
 28,434 (0.0%)      int result = cache_rd_instr(mem, addr);
  4,739 (0.0%)      return result;
  9,478 (0.0%)  }
      .         
  3,205 (0.0%)  int mmu_rd_w(struct memory *mem, int addr) {
      .             //fprintf(accesses, "mmu_rd_w(memory, 0x%x);\n", addr);
  2,564 (0.0%)      if (addr & 0b11)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
  3,846 (0.0%)      int result = cache_rd_w(mem, addr);
    641 (0.0%)      return result;
  1,282 (0.0%)  }
      .         
      .         int mmu_rd_h(struct memory *mem, int addr) {
      .             //fprintf(accesses, "mmu_rd_h(memory, 0x%x);\n", addr);
      .             //fprintf(accesses, "Reading a half from 0x%x\n", addr);
      .             if (addr & 0b1)
      .             {
      .                 printf("Unaligned word write to %x\n", addr);
      .                 exit(-1);
      .             }
      .             int result = cache_rd_h(mem, addr);
      .             return result;
      .         }
      .         
     40 (0.0%)  int mmu_rd_b(struct memory *mem, int addr) {
      .             //fprintf(accesses, "mmu_rd_b(memory, 0x%x);\n", addr);
     48 (0.0%)      int result = cache_rd_b(mem, addr);
      8 (0.0%)      return result;
     16 (0.0%)  

--------------------------------------------------------------------------------
-- Annotated source file: /home/zupreme/Documents/University/TheMemoryHole/engine/read_exec.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 8 ----------------------------------------
      .         
      .         #define MAXLINE 1024
      .         char line[MAXLINE];
      .         char hexes[4][9]; // 8+1 for zero termination
      .         char symbol[1024];
      .         char opcode[8], args[16], rest[24];
      .         
      .         int is_hex(char c)
160,200 (0.2%)  {
160,184 (0.2%)    if (c >= '0' && c <= '9')
 69,928 (0.1%)      return 1;
 19,700 (0.0%)    if (c >= 'a' && c <= 'f')
  9,368 (0.0%)      return 1;
    402 (0.0%)    return 0;
 80,100 (0.1%)  }
      .         
      .         int to_hex(char c)
158,592 (0.2%)  {
158,592 (0.2%)    if (c >= '0' && c <= '9')
104,892 (0.1%)      return c - '0';
 18,736 (0.0%)    if (c >= 'a' && c <= 'f')
 14,052 (0.0%)      return c - 'a' + 10;
      .           if (c >= 'A' && c <= 'F')
      .             return c - 'A' + 10;
      .           return 0; // silence a warning
 79,296 (0.1%)  }
      .         
      .         int to_hex2(char a, char b)
158,592 (0.2%)  {
178,416 (0.2%)    return to_hex(a) * 16 + to_hex(b);
 59,472 (0.1%)  }
      .         
      .         // count number of 2-digit hexes in "size" strings of max 4 hexes each
      .         int count_hexes(char hexes[][9], int size)
  8,185 (0.0%)  {
  1,637 (0.0%)    int num = 0;
 27,997 (0.0%)    for (int k = 0; k < size; ++k)
      .           {
140,364 (0.2%)      for (int i = 0; i < 8; i++)
      .             {
600,750 (0.8%)        if (is_hex(hexes[k][i]))
 79,296 (0.1%)          num++;
      .               else
  2,412 (0.0%)          return num / 2;
      .             }
      .           }
  6,175 (0.0%)    return num / 2;
  3,274 (0.0%)  }
      .         
      .         int read_exec(struct memory *mem, struct assembly *as, const char *name, FILE *log_file)
     10 (0.0%)  {
      .           FILE *fp;
      6 (0.0%)    fp = fopen(name, "r");
      2 (0.0%)    if (fp == NULL)
      .           {
      .             printf("Error: could not open file '%s'. Exiting\n", name);
      .             exit(-1);
      .           }
      1 (0.0%)    int count = 0;
      1 (0.0%)    int start_addr = -1; // invalid starting addr
 14,617 (0.0%)    while (fgets(line, MAXLINE, fp))
      .           {
      .             // remove any trailing newline:
  9,130 (0.0%)      int last = strlen(line) - 1;
 10,956 (0.0%)      if (line[last] == '\n')
  7,304 (0.0%)        line[last] = 0;
  3,652 (0.0%)      char *msg = "Ukendt";
      .             unsigned int addr;
      .             unsigned int a;            // value
  1,826 (0.0%)      int num_hex = 0;
 27,390 (0.0%)      int n = sscanf(line, " %x %s%s%s%s*c[ ]*c[]", &addr, hexes[0], hexes[1], hexes[2], hexes[3]);
  3,652 (0.0%)      if (n >= 2)
      .             {
 11,459 (0.0%)        num_hex = count_hexes(hexes, n - 1);
      .             }
  3,652 (0.0%)      if (num_hex)
      .             {
      .            
  2,490 (0.0%)        msg = "Data";
 86,766 (0.1%)        for (int i = 0; i < num_hex; ++i)
      .               {
118,944 (0.2%)          int block = i / 4;
198,240 (0.3%)          int disp = (i % 4) * 2;
574,896 (0.8%)          int data = to_hex2(hexes[block][disp], hexes[block][disp + 1]);
158,592 (0.2%)          mmu_wr_b_instr(mem, addr, data);
 59,472 (0.1%)          ++addr;
      .               }
      .             }
  9,877 (0.0%)      else if ((n = sscanf(line, " %x: %x %7s %15s %23s", &addr, &a, opcode, args, rest)) >= 2)
      .             {
    592 (0.0%)        msg = "Insn";
  2,072 (0.0%)        mmu_wr_w_instr(mem, addr, a);
    592 (0.0%)        if (n > 2)
      .               {
      .                 char text[64];
    592 (0.0%)          if (n == 3)
      .                 {
    208 (0.0%)            sprintf(text, "%-8s", opcode);
      .                 }
    540 (0.0%)          else if (n == 4)
      .                 {
  1,712 (0.0%)            sprintf(text, "%-8s %-16s", opcode, args);
      .                 }
    112 (0.0%)          else if (n == 5)
      .                 {
    504 (0.0%)            sprintf(text, "%-8s %-16s %-24s", opcode, args, rest);
      .                 }
  2,368 (0.0%)          assembly_set(as, addr, text);
      .               }
      .             }
  2,850 (0.0%)      else if (sscanf(line, "%x <%s", &addr, symbol) == 2)
      .             {
     34 (0.0%)        msg = "Entry";
      .               // sscanf included the terminating ">:" in the string, check for it here:
    119 (0.0%)        if (strcmp(symbol, "_start>:") == 0)
      .               {
      2 (0.0%)          msg = "Start";
      2 (0.0%)          start_addr = addr;
      .               }
      .             }
  1,826 (0.0%)      ++count;
  3,652 (0.0%)      if (log_file)
      .               fprintf(log_file, "%d -- %s -- %s\n", count, msg, line);
      .           }
      2 (0.0%)    if (start_addr != -1)
      1 (0.0%)      return start_addr;
      .           printf("Start symbol not found in file. Terminating");
      .           exit(-1);
      .           return 0; // silence warning
      5 (0.0%)  }

--------------------------------------------------------------------------------
-- Annotated source file: /home/zupreme/Documents/University/TheMemoryHole/engine/simulate.c
--------------------------------------------------------------------------------
Ir____________ 

-- line 30 ----------------------------------------
      .         void ProcessU_L(int instruction);                     // Load Upper Immediate
      .         void ProcessU_A(int instruction);                     // Add unsigned immediate to PC (auipc)
      .         void PrintRegisters();                                // Function that prints register overview for debugging
      .         void wrInstToLog(struct assembly *as, int jump);      // Writes information about the current instruction to a log file
      .         
      .         FILE* CACHE_LOG_POINTER;
      .         
      .         // Simulates provided RISC-V assembly instructions.
     11 (0.0%)  long int simulate(struct memory *mem, struct assembly *as, int start_addr, FILE *log_file, struct hashmap *map) {
      3 (0.0%)      CACHE_LOG_POINTER = get_cache_log();
      6 (0.0%)      fprintf(CACHE_LOG_POINTER, "---- PROGRAM START ----\n");
      .         
      2 (0.0%)      PC = start_addr;                                  // Initializing PC
      3 (0.0%)      uint32_t prevPC = PC-4;                           // Used for keeping track of if we jumped or not
      1 (0.0%)      int instructionCount = 0;                         // Instruction count for return value
      4 (0.0%)      log_enabled = (log_file != NULL);                 // Only log information to file if file was supplied
      2 (0.0%)      log_file_global = log_file;                       // Making the log file visible everywhere
      .         
      .             // Main Instruction Loop
      .             while (1) {
 14,214 (0.0%)          if (log_enabled) {
      .                     int isJump = prevPC+4 != PC;
      .                     wrInstToLog(as, isJump);
      .                 }
      .         
      .                 // Read next instruction
 28,428 (0.0%)          fprintf(CACHE_LOG_POINTER, "fetch: ");
 33,166 (0.0%)          int instructionInt = mmu_rd_instr(mem, PC);
 28,428 (0.0%)          fprintf(CACHE_LOG_POINTER, "endfetch\n");
      .         
 28,428 (0.0%)          fprintf(CACHE_LOG_POINTER, "instr:\n");
      .                 // Least significant 6 bits of instruction make up the OPCODE
 14,214 (0.0%)          uint32_t OPCODE = instructionInt & 0x7F; 
 28,428 (0.0%)          ExecuteInstruction(OPCODE, instructionInt, mem); // Perform current instruction
      .         
 47,380 (0.1%)          const ProgramLineMap_t *plm = hashmap_get(map, &(ProgramLineMap_t){.pc=PC});
  9,476 (0.0%)          if (plm != NULL) {
 46,404 (0.1%)              fprintf(CACHE_LOG_POINTER, "pc %d %d %d\n", plm->pc, plm->start, plm->end);
      .                 }
      .                 
 42,642 (0.1%)          fprintf(CACHE_LOG_POINTER, "CS %u\n", mmu_get_checksum());
 28,428 (0.0%)          fprintf(CACHE_LOG_POINTER, "endinstr\n");
      .                 
      .         
      .                 // Increment PC and instruction count
  9,476 (0.0%)          prevPC = PC;
 40,084 (0.1%)          PC += advancePC ? stepSize : 0;
  4,738 (0.0%)          instructionCount++;
  4,738 (0.0%)          advancePC = 1;
      .                 
 14,214 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file, "\n"); // End each instruction log with a newline
      .                 }
      .                 // Terminate if flag was turned on during instruction
 14,214 (0.0%)          if (terminateFlag) {break;}
      .             }
      .         
      .             ////// DEBUGGING ////// 
      .             // PrintRegisters(); // Uncomment this line to see contents of registers at end of execution.
      .             ////// DEBUGGING //////
      .         
      2 (0.0%)      return instructionCount;
      5 (0.0%)  }
      .         
      .         // We always use this setter to write to registers so that we don't overwrite x0
 13,905 (0.0%)  void wrReg(int registerID, int data) {
  5,624 (0.0%)      if (registerID == 0) {return;}
 19,033 (0.0%)      fprintf(CACHE_LOG_POINTER, "w %d %d\n", registerID, data);
 19,033 (0.0%)      R[registerID] = data;
  5,562 (0.0%)  }
      .         
 29,036 (0.0%)  int rdReg(int registerID) {
 50,813 (0.1%)      fprintf(CACHE_LOG_POINTER, "r %d\n", registerID);
 36,295 (0.1%)      return R[registerID];
 14,518 (0.0%)  }
      .         
      .         // This function takes an OPCODE and a full instruction integer and delegates to
      .         // more specific functions that handle each type of OPCODE instruction.
 28,428 (0.0%)  void ExecuteInstruction(int OPCODE, int instruction, struct memory *mem) {
122,600 (0.2%)      switch (OPCODE) {
      .                 case 0x33: // R
  1,911 (0.0%)              ProcessR(instruction);
    637 (0.0%)              break;
      .                 case 0x13: // I (Immediate arithmetics)
  4,230 (0.0%)              ProcessI_A(instruction);
  1,410 (0.0%)              break;
      .                 case 0x3: // I-2 (Loads)
  3,205 (0.0%)              ProcessI_L(instruction, mem);
    641 (0.0%)              break;
      .                 case 0x73: // I-3 (ecall)
     15 (0.0%)              ProcessI_E(instruction);
      5 (0.0%)              break;
      .                 case 0x67: // I-4 (jalr)
     63 (0.0%)              ProcessI_J(instruction);
     21 (0.0%)              break;
      .                 case 0x23: // S
  3,200 (0.0%)              ProcessS(instruction, mem);
    640 (0.0%)              break;
      .                 case 0x63: // B
  3,936 (0.0%)              ProcessB(instruction);
  1,312 (0.0%)              break;
      .                 case 0x6F: // J
    156 (0.0%)              ProcessJ(instruction);
     52 (0.0%)              break;
      .                 case 0x37: // U
     27 (0.0%)              ProcessU_L(instruction);
      9 (0.0%)              break;
      .                 case 0x17: // U-2
     33 (0.0%)              ProcessU_A(instruction);
     11 (0.0%)              break;
      .                 default:
      .                     printf("Upcode didn't match any expected types\n");
      .                     exit(-1);
      .             }
  4,738 (0.0%)      return;
  9,476 (0.0%)  }
      .         
      .         // Proccesses R instructions.
  3,185 (0.0%)  void ProcessR(int instruction) {
      .             // Parsing instruction
  2,548 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
  2,548 (0.0%)      uint32_t funct3 = (instruction >> 12) & 0x7;
  2,548 (0.0%)      uint32_t rs1 =  (instruction >> 15) & 0x1F;
  2,548 (0.0%)      uint32_t rs2 = (instruction >> 20) & 0x1F;
  1,911 (0.0%)      uint32_t funct7 = (instruction >> 25) & 0x7F;
      .         
 16,442 (0.0%)      switch (funct3) {
      .             case 0x0: // Add/Sub/Mul
  1,262 (0.0%)          if (funct7 == 0x20) { // Sub
      3 (0.0%)              if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d - %d = %d)", rd, R[rs1], R[rs2], R[rs1] - R[rs2]);
      .                     }
      9 (0.0%)              fprintf(CACHE_LOG_POINTER, "SUB %d, %d, %d\n", rd, rs1, rs2);
     13 (0.0%)              wrReg(rd, rdReg(rs1) - rdReg(rs2));
  1,260 (0.0%)          } else if (funct7 == 0x00) { // Add
  1,890 (0.0%)              if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d + %d = %d)", rd, R[rs1], R[rs2], R[rs1] + R[rs2]);
      .                     }
  5,670 (0.0%)              fprintf(CACHE_LOG_POINTER, "ADD %d, %d, %d\n", rd, rs1, rs2);
  7,560 (0.0%)              wrReg(rd, rdReg(rs1) + rdReg(rs2));
      .                 } else if (funct7 == 0x01) { // Mul
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d * %d = %d)", rd, R[rs1], R[rs2], R[rs1] * R[rs2]);
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "MUL %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, rdReg(rs1) * rdReg(rs2));
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
    631 (0.0%)          break;
      .             case 0x4: // XOR or Div
      .                 if (funct7 == 0x00) { // XOR
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d ^ %d = %d)", rd, R[rs1], R[rs2], R[rs1] ^ R[rs2]);
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "XOR %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, rdReg(rs1) ^ rdReg(rs2));
      .                 } else if (funct7 == 0x01) { // Div
-- line 187 ----------------------------------------
-- line 223 ----------------------------------------
      .                         }
      .                         wrReg(rd, R[rs1] % R[rs2]);
      .                     }
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
      .                 break;
      .             case 0x7: // AND and Remainder (U)
      6 (0.0%)          if (funct7 == 0x00) { // AND
      .                     fprintf(CACHE_LOG_POINTER, "ANDU %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, rdReg(rs1) & rdReg(rs2));
      6 (0.0%)          } else if (funct7 == 0x01) { // Remainder (U)
     27 (0.0%)              fprintf(CACHE_LOG_POINTER, "REMU %d, %d, %d\n", rd, rs1, rs2);
      9 (0.0%)              rdReg(rs1);
      9 (0.0%)              rdReg(rs2);
     18 (0.0%)              if (R[rs2] == 0) { // Division by zero
      .                         wrReg(rd, R[rs1]);
      .                     } else {
     15 (0.0%)                  unsigned int u1 = (unsigned int)R[rs1];
     15 (0.0%)                  unsigned int u2 = (unsigned int)R[rs2];
      9 (0.0%)                  if (log_enabled) {
      .                             fprintf(log_file_global, "R[%d] <- (%u mod %u = %d)", rd, u1, u2, u1 % u2);
      .                         }
     27 (0.0%)                  wrReg(rd, u1 % u2);
      .                     }
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
      3 (0.0%)          break;
      .             case 0x1: // Shift-L Logical
      .                 if (funct7 == 0x00) {
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d << %d = %d)", rd, R[rs1], R[rs2], R[rs1] << R[rs2]);
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "SLL %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, rdReg(rs1) << rdReg(rs2));
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
      .                 break;
      .             case 0x5: // Shift-R Logical/Arithmetic and div (U)
      6 (0.0%)          if (funct7 == 0x20) {
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d >> %d = %d)", rd, R[rs1], R[rs2], R[rs1] >> R[rs2]);
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "SRA %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, rdReg(rs1) >> rdReg(rs2)); // Arithmetic
      6 (0.0%)          } else if (funct7 == 0x00) {
      .                     unsigned int u1 = (unsigned int)rdReg(rs1);
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "R[%d] <- (%d >> %d = %d)", rd, u1, R[rs2], (int)((u1) >> R[rs2]));
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "SRL %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, (int)((u1) >> rdReg(rs2))); // Logical
      6 (0.0%)          } else if (funct7 == 0x01) { // Div (U)
     27 (0.0%)              fprintf(CACHE_LOG_POINTER, "DIVU %d, %d, %d\n", rd, rs1, rs2);
      9 (0.0%)              rdReg(rs1);
      9 (0.0%)              rdReg(rs2);
     18 (0.0%)              if (R[rs2] == 0) { // Division by zero
      .                         wrReg(rd, UINT32_MAX);
      .                     } else {
     15 (0.0%)                  unsigned int u1 = (unsigned int)R[rs1];
     15 (0.0%)                  unsigned int u2 = (unsigned int)R[rs2];
      9 (0.0%)                  if (log_enabled) {
      .                             fprintf(log_file_global, "R[%d] <- (%d / %d = %d)", rd, u1, u2, u1 / u2);
      .                         }
     24 (0.0%)                  wrReg(rd, u1 / u2); 
      .                     }
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
      3 (0.0%)          break;
      .             case 0x2: // Set if LT
      .                 if (funct7 == 0x00) {
      .                     fprintf(CACHE_LOG_POINTER, "SLT %d, %d, %d\n", rd, rs1, rs2);
      .                     wrReg(rd, (rdReg(rs1) < rdReg(rs2))?1:0);
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
      .                 break;
-- line 302 ----------------------------------------
-- line 309 ----------------------------------------
      .                 } else {
      .                     printf("Unexpected funct7 value.\n");
      .                 }
      .                 break;
      .             default:
      .                 printf("Unexpected funct3\n");
      .                 break;
      .             }
  2,548 (0.0%)  }
      .         
      .         // Proccesses arithmetic I instructions.
  5,640 (0.0%)  void ProcessI_A(int instruction) {
      .             // Parsing instruction
  5,640 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
  5,640 (0.0%)      uint32_t funct3 = (instruction >> 12) & 0x7;
  5,640 (0.0%)      uint32_t rs1 = (instruction >> 15) & 0x1F;
  4,230 (0.0%)      int imm = instruction & 0xFFF00000;
  1,410 (0.0%)      imm = imm >> 20;
  5,640 (0.0%)      uint32_t funct7 = (imm >> 5) & 0x7F;
  4,230 (0.0%)      uint32_t shiftValue = imm & 0x1F;
      .         
 36,660 (0.1%)      switch (funct3) {
      .             case 0x0:; // ADD Immediate // The semi colon on this line supresses a warning
  7,050 (0.0%)          int rs1Val = R[rs1];
 12,690 (0.0%)          fprintf(CACHE_LOG_POINTER, "ADDI %d, %d, %d\n", rd, rs1, imm);
 12,690 (0.0%)          wrReg(rd, rdReg(rs1) + imm);
  4,230 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "R[%d] <- (%d + %d = %d)", rd, rs1Val, imm, rs1Val + imm);
      .                 }
  2,820 (0.0%)          break;
      .             case 0x4: // XOR Immediate
      .                 fprintf(CACHE_LOG_POINTER, "XORI %d, %d, %d\n", rd, rs1, imm);
      .                 wrReg(rd, rdReg(rs1) ^ imm);
      .                 if (log_enabled) {
      .                     fprintf(log_file_global, "R[%d] <- (%d ^ %d = %d)", rd, R[rs1], imm, R[rs1] ^ imm);
      .                 }
      .                 break;
      .             case 0x6: // OR Immediate
-- line 346 ----------------------------------------
-- line 402 ----------------------------------------
      .                     fprintf(log_file_global, "R[%d] <- (%u < %u = %d)", rd, u1, uImm, (u1 < uImm)?1:0);
      .                 }
      .                 fprintf(CACHE_LOG_POINTER, "SLTIU %d, %d, %d\n", rd, rs1, uImm);
      .                 wrReg(rd, (u1 < uImm)?1:0);
      .                 break;        
      .             default:
      .                 break;
      .             }
  4,230 (0.0%)  }
      .         
      .         // Proccesses load I instructions.
  3,205 (0.0%)  void ProcessI_L(int instruction, struct memory *mem) {
      .             // Parsing instruction
  2,564 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
  2,564 (0.0%)      uint32_t funct3 = (instruction >> 12) & 0x7;
  2,564 (0.0%)      uint32_t rs1 = (instruction >> 15) & 0x1F;
  1,923 (0.0%)      int imm = (instruction & 0xFFF00000) >> 20;
      .         
    641 (0.0%)      int valueToSave = 0;
    641 (0.0%)      int valueToSaveSE = 0;
    641 (0.0%)      int log_offset = 0;
      .         
  6,378 (0.0%)      switch (funct3) {
      .                 case 0x0: // Load Byte
      .                     valueToSave = mmu_rd_b(mem, rdReg(rs1) + imm);
      .                     valueToSaveSE = (valueToSave << 24) >> 24;
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "Load %d into R[%d] from %x", valueToSaveSE, rd, R[rs1] + imm);
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "LB %d, %d(%d)\n", rd, imm, rs1);
      .                     wrReg(rd, valueToSaveSE);
-- line 432 ----------------------------------------
-- line 436 ----------------------------------------
      .                     valueToSaveSE = (valueToSave << 16) >> 16;
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "Load %d into R[%d] from %x", valueToSaveSE, rd, R[rs1] + imm);
      .                     }
      .                     fprintf(CACHE_LOG_POINTER, "LH %d, %d(%d)\n", rd, imm, rs1);
      .                     wrReg(rd, valueToSaveSE);
      .                     break;
      .                 case 0x2: // Load Word
  4,431 (0.0%)              log_offset = R[rs1] + imm;
  5,697 (0.0%)              fprintf(CACHE_LOG_POINTER, "LW %d, %d(%d)\n", rd, imm, rs1);
  8,862 (0.0%)              wrReg(rd, mmu_rd_w(mem, rdReg(rs1) + imm));
  1,899 (0.0%)              if (log_enabled) {
      .                         fprintf(log_file_global, "Load %d into R[%d] from %x", R[rd], rd, log_offset);
      .                     }
  1,266 (0.0%)              break;
      .                 case 0x4: // Load Byte (U)
     56 (0.0%)              log_offset = R[rs1] + imm;
     72 (0.0%)              fprintf(CACHE_LOG_POINTER, "LBU %d, %d(%d)\n", rd, imm, rs1);
    112 (0.0%)              wrReg(rd, mmu_rd_b(mem, rdReg(rs1) + imm));
     24 (0.0%)              if (log_enabled) {
      .                         fprintf(log_file_global, "Load %d into R[%d] from %x", R[rd], rd, log_offset);
      .                     }
     16 (0.0%)              break;
      .                 case 0x5: // Load Half (U)
      .                     log_offset = R[rs1] + imm;
      .                     fprintf(CACHE_LOG_POINTER, "LHU %d, %d(%d)\n", rd, imm, rs1);
      .                     wrReg(rd, mmu_rd_h(mem, rdReg(rs1) + imm));
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "Load %d into R[%d] from %x", R[rd], rd, log_offset);
      .                     }
      .                     break;    
      .                 default:
      .                     break;
      .             }
  1,923 (0.0%)  }
      .         
      .         // Proccesses ecall I instructions.
     20 (0.0%)  void ProcessI_E(int instruction) {
      .             // Parsing instruction
     15 (0.0%)      int imm = instruction & 0xFFF00000;
      5 (0.0%)      imm = imm >> 20;
      .         
      .         
     30 (0.0%)      fprintf(CACHE_LOG_POINTER, "ecall\n");
     20 (0.0%)      int callType = rdReg(A7); // A7
      .         
     54 (0.0%)      switch (callType) {
      .                 case 1: // return getchar() in A0
      .                     wrReg(A0, getchar());
      .                     if (log_enabled) {
      .                         fprintf(log_file_global, "Got '%c' from user", R[A0]);
      .                     }
      .                     break;
      .                 case 2: // execute putchar(c), where c is taken from A0
     12 (0.0%)              if (log_enabled) {
      .                         fprintf(log_file_global, "Wrote '%c' to user", R[A0]);
      .                     }
     20 (0.0%)              putchar(rdReg(A0));
     44 (0.0%)              fprintf(CACHE_LOG_POINTER, "stdout %d\n", R[A0]);
      4 (0.0%)              break;
      .                 case 3: // terminate simulation
      .                 case 93:
      1 (0.0%)              terminateFlag = 1;
      3 (0.0%)              if (log_enabled) {
      .                         fprintf(log_file_global, "Terminating program");
      .                     }
      1 (0.0%)              break;
      .                 default:
      .                     break;
      .             }
     15 (0.0%)  }
      .         
      .         // Proccesses I instructions.
     84 (0.0%)  void ProcessI_J(int instruction) {
      .             // Parsing instruction
     84 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
     84 (0.0%)      uint32_t funct3 = (instruction >> 12) & 0x7;
     84 (0.0%)      uint32_t rs1 = (instruction >> 15) & 0x1F;
     63 (0.0%)      int imm = instruction & 0xFFF00000;
     21 (0.0%)      imm = imm >> 20;
      .         
     42 (0.0%)      if (funct3 == 0x0) { // Jump And Link Register
    189 (0.0%)          fprintf(CACHE_LOG_POINTER, "JALR %d, %d, %d\n", rd, rs1, imm);
     84 (0.0%)          int offset = rdReg(rs1);
     63 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "Jump %x -> %x", PC, offset + imm);
      .                 }
    147 (0.0%)          wrReg(rd, PC+4);
     84 (0.0%)          PC = offset + imm;
     21 (0.0%)          advancePC = 0;
      .             } else {
      .                 printf("Unexpected funct3 value\n");
      .             }
     84 (0.0%)  }
      .         
      .         // Proccesses S instructions.
  3,840 (0.0%)  void ProcessS(int instruction, struct memory *mem) {
      .             // Parsing instruction
  1,920 (0.0%)      int immUpper = (instruction & 0xFE000000);
    640 (0.0%)      immUpper = immUpper >> 20; // Sign extending
  2,560 (0.0%)      int immLower = ((instruction >> 7) & 0x1F);
  1,920 (0.0%)      int imm = immUpper | immLower;
  2,560 (0.0%)      uint32_t funct3 = (instruction >> 12) & 0x7;
  2,560 (0.0%)      uint32_t rs1 = (instruction >> 15) & 0x1F;
  2,560 (0.0%)      uint32_t rs2 = (instruction >> 20) & 0x1F;
      .         
  1,304 (0.0%)      switch (funct3) {
      .             case 0x0: // Store Byte
     54 (0.0%)          fprintf(CACHE_LOG_POINTER, "SB %d, %d(%d)\n", rs2, imm, rs1);
     84 (0.0%)          mmu_wr_b(mem, rdReg(rs1) + imm, rdReg(rs2));
     18 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "(%x+%x=%x) <- %d", imm, R[rs1], R[rs1] + imm, R[rs2]);
      .                 } 
      6 (0.0%)          break;
      .             case 0x1: // Store Half
      .                 if (log_enabled) {
      .                     fprintf(log_file_global, "%x <- %d", R[rs1] + imm, R[rs2]);
      .                 }
      .                 fprintf(CACHE_LOG_POINTER, "SH %d, %d(%d)\n", rs2, imm, rs1);
      .                 mmu_wr_h(mem, rdReg(rs1) + imm, rdReg(rs2));
      .                 break;
      .             case 0x2: // Store Word
  1,902 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "%x <- %d", R[rs1] + imm, R[rs2]);
      .                 }
  5,706 (0.0%)          fprintf(CACHE_LOG_POINTER, "SW %d, %d(%d)\n", rs2, imm, rs1);
  8,876 (0.0%)          mmu_wr_w(mem, rdReg(rs1) + imm, rdReg(rs2));
    634 (0.0%)          break;
      .             default:
      .                 break;
      .             }
  2,560 (0.0%)  }
      .         
      .         // Proccesses B instructions.
  6,560 (0.0%)  void ProcessB(int instruction) {
      .             // Parsing instruction
  5,248 (0.0%)      uint32_t rs1 =  (instruction >> 15) & 0x1F;
  5,248 (0.0%)      uint32_t rs2 = (instruction >> 20) & 0x1F;
  5,248 (0.0%)      uint32_t funct3 = (instruction >> 12) & 0x7;
  5,248 (0.0%)      int upper = ((instruction >> 31) & 0x1) << 12;
  6,560 (0.0%)      int upperMid = ((instruction >> 7) & 0x1) << 11;
  6,560 (0.0%)      int lowerMid = ((instruction >> 25) & 0x3F) << 5;
  6,560 (0.0%)      int lower = ((instruction >> 8) & 0xF) << 1;
  9,184 (0.0%)      int imm = ((upper | upperMid | lowerMid | lower) << 19) >> 19; // Sign extending 
      .         
      .             unsigned int u1;
      .             unsigned int u2;
      .         
 26,060 (0.0%)      switch (funct3) {
      .             case 0x0: // Branch ==
    159 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "%d == %d = %d", R[rs1], R[rs2], R[rs1] == R[rs2]);
      .                 }
    477 (0.0%)          fprintf(CACHE_LOG_POINTER, "BEQ %d, %d, %d\n", rs1, rs2, imm);
    487 (0.0%)          if (rdReg(rs1) == rdReg(rs2)) {PC += imm; advancePC = 0;}
    108 (0.0%)          break;
      .             case 0x1: // Branch !=
  3,762 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "%d != %d = %d", R[rs1], R[rs2], R[rs1] != R[rs2]);
      .                 }
 11,286 (0.0%)          fprintf(CACHE_LOG_POINTER, "BNE %d, %d, %d\n", rs1, rs2, imm);
 17,296 (0.0%)          if (rdReg(rs1) != rdReg(rs2)) {PC += imm; advancePC = 0;}
  3,710 (0.0%)          break;
      .             case 0x4: // Branch <
      .                 if (log_enabled) {
      .                     fprintf(log_file_global, "%d < %d = %d", R[rs1], R[rs2], R[rs1] < R[rs2]);
      .                 }
      .                 fprintf(CACHE_LOG_POINTER, "BLT %d, %d, %d\n", rs1, rs2, imm);
      .                 if (rdReg(rs1) < rdReg(rs2)) {PC += imm; advancePC = 0;}
      .                 break;
      .             case 0x5: // Branch >=
      .                 if (log_enabled) {
      .                     fprintf(log_file_global, "%d >= %d = %d", R[rs1], R[rs2], R[rs1] >= R[rs2]);
      .                 }
      .                 fprintf(CACHE_LOG_POINTER, "BGE %d, %d, %d\n", rs1, rs2, imm);
      .                 if (rdReg(rs1) >= rdReg(rs2)) {PC += imm; advancePC = 0;}
      .                 break;
      .             case 0x6: // Branch < (U)
     36 (0.0%)          fprintf(CACHE_LOG_POINTER, "BLTU %d, %d, %d\n", rs1, rs2, imm);
     16 (0.0%)          u1 = (unsigned int)rdReg(rs1);
     16 (0.0%)          u2 = (unsigned int)rdReg(rs2);
     12 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "%u < %u = %d", u1, u2, u1 < u2);
      .                 }
     22 (0.0%)          if (u1 < u2) {PC += imm; advancePC = 0;}
     10 (0.0%)          break;
      .             case 0x7: // Branch >= (U)
      9 (0.0%)          fprintf(CACHE_LOG_POINTER, "BGEU %d, %d, %d\n", rs1, rs2, imm);
      4 (0.0%)          u1 = (unsigned int)rdReg(rs1);
      4 (0.0%)          u2 = (unsigned int)rdReg(rs2);
      3 (0.0%)          if (log_enabled) {
      .                     fprintf(log_file_global, "%u >= %u = %d", u1, u2, u1 >= u2);
      .                 }
      3 (0.0%)          if (u1 >= u2) {PC += imm; advancePC = 0;}
      1 (0.0%)          break;
      .             default:
      .                 break;
      .             }
  5,248 (0.0%)  }
      .         
      .         // Proccesses J instructions.
    208 (0.0%)  void ProcessJ(int instruction) {
      .             // Parsing instruction
    208 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
    208 (0.0%)      int upper = ((instruction >> 31) & 0x1) << 20;
    156 (0.0%)      int upperMid = ((instruction >> 12) & 0xFF) << 12;
    260 (0.0%)      int lowerMid = ((instruction >> 20) & 0x1) << 11;
    260 (0.0%)      int lower = ((instruction >> 21) & 0x3FF) << 1;
    364 (0.0%)      int imm = ((upper | upperMid | lowerMid | lower) << 11) >> 11; // Sign extending
      .         
      .             // Jump and Link
    156 (0.0%)      if (log_enabled) {
      .                 fprintf(log_file_global, "Jump %x -> %x", PC, PC + imm);
      .             }
    208 (0.0%)      PC += imm;
     52 (0.0%)      advancePC = 0;
      .             
    364 (0.0%)      fprintf(CACHE_LOG_POINTER, "JAL %d, %d\n", rd, imm);
    312 (0.0%)      wrReg(rd, PC);
    156 (0.0%)  }
      .         
      .         // Proccesses U Load instructions.
     36 (0.0%)  void ProcessU_L(int instruction) {
      .             // Parsing instruction
     36 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
     27 (0.0%)      int imm = instruction & 0xFFFFF000;
      .             
      .             // Load Upper Imm
     63 (0.0%)      fprintf(CACHE_LOG_POINTER, "LUI %d, %d\n", rd, imm);
     45 (0.0%)      wrReg(rd, imm);
     27 (0.0%)      if (log_enabled) {
      .                 fprintf(log_file_global, "R[%d] <- %x", rd, R[rd]);
      .             }
     27 (0.0%)  }
      .         
      .         // Proccesses U Add instructions
     44 (0.0%)  void ProcessU_A(int instruction) {
      .             // Parsing instruction
     44 (0.0%)      uint32_t rd = (instruction >> 7) & 0x1F;
     33 (0.0%)      int imm = instruction & 0xFFFFF000;
      .         
      .             // Write Upper Imm + PC to register
     77 (0.0%)      fprintf(CACHE_LOG_POINTER, "AUIPC %d, %d\n", rd, imm);
     88 (0.0%)      wrReg(rd, PC + imm);
     33 (0.0%)      if (log_enabled) {
      .                 fprintf(log_file_global, "R[%d] <- %x", rd, R[rd]);
      .             }
     33 (0.0%)  }
      .         
      .         void PrintRegisters() {
      .             printf("| zero = %d | ra = %d | sp = %d | gp = %d | tp = %d | t0 = %d | t1 = %d | t2 = %d |\n"
      .                    "| s0 = %d | s1 = %d | a0 = %d | a1 = %d | a2 = %d | a3 = %d | a4 = %d | a5 = %d |\n"
      .                    "| a6 = %d | a7 = %d | s2 = %d | s3 = %d | s4 = %d | s5 = %d | s6 = %d | s7 = %d |\n"
      .                    "| s8 = %d | s9 = %d | s10 = %d | s11 = %d | t3 = %d | t4 = %d | t5 = %d | t6 = %d |\n",
      .                     R[0], R[1], R[2], R[3], R[4], R[5], R[6], R[7], R[8], R[9], R[10], R[11], R[12], R[13], R[14],
      .                     R[15], R[16], R[17], R[18], R[19], R[20], R[21], R[22], R[23], R[24], R[25], R[26], R[27], R[28], R[29],
-- line 691 ----------------------------------------
-- line 699 ----------------------------------------
      .             } else {
      .                 padding -= fprintf(log_file_global, "%x  -  %s", PC, assembly_get(as, PC));
      .             }
      .             fprintf(log_file_global, "%*s", padding, "");
      .         }
      .         
      .         
      .         // for the hashmap
 19,335 (0.0%)  int programLineMap_compare(const void *a, const void *b, void*) {
  7,734 (0.0%)      const ProgramLineMap_t *ua = a;
  7,734 (0.0%)      const ProgramLineMap_t *ub = b;
 23,202 (0.0%)      return ua->pc - ub->pc;
  7,734 (0.0%)  }
      .         bool programLineMap_iter(const void *item, void*) {
      .             // TODO: i have no idea what this function is meant for or if we need it tbh
      .             const ProgramLineMap_t *plm = item;
      .             printf("pc %d, start: %d, end: %d\n", plm->pc, plm->start, plm->end);
      .             return true;
      .         }
 28,530 (0.0%)  uint64_t programLineMap_hash(const void *item, uint64_t seed0, uint64_t seed1) {
  9,510 (0.0%)      const ProgramLineMap_t *plm = item;
 28,530 (0.0%)      return hashmap_sip(&plm->pc, sizeof(int), seed0, seed1);
  9,510 (0.0%)  

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/elf/dl-lookup.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/elf/dl-lookup.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/fileops.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/fileops.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/genops.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/genops.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/iofgets.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/iofgets.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/iofwrite.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/iofwrite.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/iogetline.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/iogetline.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/libioP.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/libioP.h

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/libio/strops.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/libio/strops.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/malloc/malloc.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/malloc/malloc.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/math/../sysdeps/ieee754/dbl-64/e_pow.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/math/../sysdeps/ieee754/dbl-64/e_pow.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/posix/regex_internal.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/posix/regex_internal.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/posix/regexec.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/posix/regexec.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/../include/printf_buffer.h

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/../string/bits/string_fortified.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/../string/bits/string_fortified.h

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_done.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_done.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_write.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/Xprintf_buffer_write.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/_itoa.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/_itoa.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/fprintf.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/fprintf.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/isoc99_sscanf.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/isoc99_sscanf.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/printf-parse.h

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/printf_buffer_to_file.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/vfprintf-internal.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/vfprintf-process-arg.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/vfprintf-process-arg.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdio-common/vfscanf-internal.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdio-common/vfscanf-internal.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/stdlib/../stdlib/strtol_l.c
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/stdlib/../stdlib/strtol_l.c

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memchr-avx2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memchr-avx2.S

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/memset-vec-unaligned-erms.S

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-avx2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strchr-avx2.S

--------------------------------------------------------------------------------
-- Annotated source file: /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-avx2.S
--------------------------------------------------------------------------------
Unannotated because one or more of these original files are unreadable:
- /usr/src/debug/glibc/glibc/string/../sysdeps/x86_64/multiarch/strlen-avx2.S

--------------------------------------------------------------------------------
-- Annotation summary
--------------------------------------------------------------------------------
Ir________________ 

14,644,980 (20.5%)    annotated: files known & above threshold & readable, line numbers known
         0            annotated: files known & above threshold & readable, line numbers unknown
         0          unannotated: files known & above threshold & two or more non-identical
55,774,855 (78.0%)  unannotated: files known & above threshold & unreadable 
   695,211  (1.0%)  unannotated: files known & below threshold
   385,377  (0.5%)  unannotated: files unknown

